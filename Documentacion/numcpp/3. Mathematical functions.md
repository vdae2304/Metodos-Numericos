# Mathematical functions

Defined in: `numcpp/math.h`

## Content
- [Mathematical functions](#mathematical-functions)
  - [Content](#content)
  - [Constants](#constants)
  - [Basic functions](#basic-functions)
  - [Trigonometric functions](#trigonometric-functions)
  - [Hyperbolic functions](#hyperbolic-functions)
  - [Exponential and logarithmic functions](#exponential-and-logarithmic-functions)
  - [Power functions](#power-functions)
  - [Rounding](#rounding)
  - [Floating-point manipulation functions](#floating-point-manipulation-functions)
  - [Integer-valued functions](#integer-valued-functions)
  - [Complex numbers](#complex-numbers)
  - [Classification functions](#classification-functions)

## Constants

NumCPP defines several mathematical constants.

Floating point representation of (positive) infinity.
```cpp
template <class T>
static constexpr T constants<T>::inf;
```

Floating point representation of quiet NaN (Not a Number).
```cpp
template <class T>
static constexpr T constants<T>::nan;
```

Euler's constant, base of natural logarithm.
```cpp
template <class T>
static constexpr T constants<T>::e;
```

Pi, ratio of a circle's circunferemce to its diameter.
```cpp
template <class T>
static constexpr T constants<T>::pi;
```

Golden ratio.
```cpp
template <class T>
static constexpr T constants<T>::golden;
```

Eulerâ€“Mascheroni's constant.
```cpp
template <class T>
static constexpr T constants<T>::egamma;
```

Example

```cpp
#include <iostream>
#include "numcpp/math.h"
namespace np = numcpp;
int main() {
    std::cout << "Infinity: " << np::constants<double>::inf << '\n';
    std::cout << "NaN: " << np::constants<double>::nan << '\n';
    std::cout << "e: " << np::constants<double>::e << '\n';
    std::cout << "Pi: " << np::constants<double>::pi << '\n';
    std::cout << "Golden ratio: " << np::constants<double>::golden << '\n';
    std::cout << "Euler-Mascheroni: " << np::constants<double>::egamma << '\n';
    return 0;
}
```

Output

```
Infinity: inf
NaN: nan
e: 2.71828
Pi: 3.14159
Golden ratio: 1.61803
Euler-Mascheroni: 0.577216
```

## Basic functions

`abs`

Return the absolute value, element-wise.
```cpp
template <class T>
array<T> abs(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose absolute value is computed.

Returns

* A light-weight object with the absolute value of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`abs`

```cpp
template <class T>
matrix<T> abs(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose absolute value is computed.

Returns

* A light-weight object with the absolute value of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> x;
    std::cin >> x;
    std::cout << np::abs(x) << '\n';
    return 0;
}
```

Input

```
[2, 7, -3, 1, 0, 8, -1, 9, -5, 12]   
```

Output

```
[2, 7, 3, 1, 0, 8, 1, 9, 5, 12]
```

`fmod`

Return the floating-point remainder of `x/y`, element-wise. The floating-point 
remainder of `x/y` is `x - n*y`, where `n` is the truncated value (i.e., 
rounded towards zero) of `x/y`.
```cpp
template <class T>
array<T> fmod(const array<T> &x, const array<T> &y);

template <class T>
array<T> fmod(const array<T> &x, const typename array<T>::value_type &y);

template <class T>
array<T> fmod(const typename array<T>::value_type &x, const array<T> &y);
```

Parameters

* `x` An array-like object with the values of the quotient numerator.
* `y` An array-like object with the values of the quotient denominator.

Returns

* A light-weight object with the remainder of `x/y`. Convertible to an 
[`array`](1.%20Array.md) object.

`fmod`

Return the floating-point remainder of `x/y`, element-wise. The floating-point 
remainder of `x/y` is `x - n*y`, where `n` is the truncated value (i.e., 
rounded towards zero) of `x/y`.
```cpp
template <class T>
matrix<T> fmod(const matrix<T> &x, const matrix<T> &y);

template <class T>
matrix<T> fmod(const matrix<T> &x, const typename matrix<T>::value_type &y);

template <class T>
matrix<T> fmod(const typename matrix<T>::value_type &x, const matrix<T> &y);
```

Parameters

* `x` A matrix-like object with the values of the quotient numerator.
* `y` A matrix-like object with the values of the quotient denominator.

Returns

* A light-weight object with the remainder of `x/y`. Convertible to a 
[`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x, y;
    std::cin >> x >> y;
    std::cout << np::fmod(x, y) << '\n';
    return 0;
}
```

Input

```
[3.2, 1.7, 5.1, 10.3, 7.35]
[2, 1, 2, 5, 3] 
```

Output

```
[1.2, 0.7, 1.1, 0.3, 1.35] 
```

## Trigonometric functions

`cos`

Return the cosine, element-wise.
```cpp
template <class T>
array<T> cos(const array<T> &x);
```

Parameters

* `x` An array-like object with the angles in radians.

Returns

* A light-weight object with the cosine of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`cos`

Return the cosine, element-wise.
```cpp
template <class T>
matrix<T> cos(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the angles in radians.

Returns

* A light-weight object with the cosine of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double pi = np::constants<double>::pi;
    np::array<double> x{0, pi/6, pi/4, pi/3, pi/2, pi};
    std::cout << np::cos(x) << '\n';
    return 0;
}
```

Output

```
[1, 0.8660254, 0.70710678, 0.5, 6.1230318e-17, -1]
```

`sin`

Return the sine, element-wise.
```cpp
template <class T>
array<T> sin(const array<T> &x);
```

Parameters

* `x` An array-like object with the angles in radians.

Returns

* A light-weight object with the sine of each element in the array. Convertible 
to an [`array`](1.%20Array.md) object.

`sin`

Return the sine, element-wise.
```cpp
template <class T>
matrix<T> sin(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the angles in radians.

Returns

* A light-weight object with the sine of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double pi = np::constants<double>::pi;
    np::array<double> x{0, pi/6, pi/4, pi/3, pi/2, pi};
    std::cout << np::sin(x) << '\n';
    return 0;
}
```

Output

```
[0, 0.5, 0.70710678, 0.8660254, 1, 1.2246064e-16]
```

`tan`

Return the tangent, element-wise.
```cpp
template <class T>
array<T> tan(const array<T> &x);
```

Parameters

* `x` An array-like object with the angles in radians.

Returns

* A light-weight object with the tangent of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`tan`

Return the tangent, element-wise.
```cpp
template <class T>
matrix<T> tan(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the angles in radians.

Returns

* A light-weight object with the tangent of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double pi = np::constants<double>::pi;
    np::array<double> x{0, pi/6, pi/4, pi/3, pi};
    std::cout << np::tan(x) << '\n';
    return 0;
}
```

Output

```
[0, 0.57735027, 1, 1.7320508, -1.2246468e-16]
```

`hypot`

Return the hypotenuse of a right-angled triangle whose legs are `x` and `y`, 
element-wise.
```cpp
template <class T>
array<T> hypot(const array<T> &x, const array<T> &y);

template <class T>
array<T> hypot(const array<T> &x, const typename array<T>::value_type &y);

template <class T>
array<T> hypot(const typename array<T>::value_type &x, const array<T> &y);
```

Parameters

* `x` An array-like object with one of the legs of the right-angle triangles.
* `y` An array-like object with one of the legs of the right-angle triangles.

Returns

* A light-weight object with the hypotenuse of the triangles. Convertible to an 
[`array`](1.%20Array.md) object.

`hypot`

Return the hypotenuse of a right-angled triangle whose legs are `x` and `y`, element-wise.
```cpp
template <class T>
matrix<T> hypot(const matrix<T> &x, const matrix<T> &y);

template <class T>
matrix<T> hypot(const matrix<T> &x, const typename matrix<T>::value_type &y);

template <class T>
matrix<T> hypot(const typename matrix<T>::value_type &x, const matrix<T> &y);
```

Parameters

* `x` A matrix-like object with one of the legs of the right-angle triangles.
* `y` A matrix-like object with one of the legs of the right-angle triangles.

Returns

* A light-weight object with the hypotenuse of the triangles. Convertible to a 
[`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x, y;
    std::cin >> x >> y;
    std::cout << np::hypot(x, y) << '\n';
    return 0;
}
```

Input

```
[3, 1, 5, 2, 8]
[4, 1, 12, 5, 15]
```

Output

```
[5, 1.4142136, 13, 5.3851648, 17]
```

`acos`

Return the principal value of the arc cosine, element-wise.
```cpp
template <class T>
array<T> acos(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose arc cosine is computed.

Returns

* A light-weight object with the arc cosine, in radians, of each value in the 
array. Convertible to an [`array`](1.%20Array.md) object.

`acos`

Return the principal value of the arc cosine, element-wise.
```cpp
template <class T>
matrix<T> acos(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose arc cosine is computed.

Returns

* A light-weight object with the arc cosine, in radians, of each value in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x{1, np::sqrt(3)/2, 1/np::sqrt(2), 0.5, 0, -1};
    std::cout << np::acos(x) << '\n';
    return 0;
}
```

Output

```
[0, 0.52359878, 0.78539816, 1.0471976, 1.5707963, 3.1415927]
```

`asin`

Return the principal value of the arc sine, element-wise.
```cpp
template <class T>
array<T> asin(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose arc sine is computed.

Returns

* A light-weight object with the arc sine, in radians, of each value in the 
array. Convertible to an [`array`](1.%20Array.md) object.

`asin`

Return the principal value of the arc sine, element-wise.
```cpp
template <class T>
matrix<T> asin(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose arc sine is computed.

Returns

* A light-weight object with the arc sine, in radians, of each value in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x{-1, 0, 0.5, 1/np::sqrt(2), np::sqrt(3)/2, 1};
    std::cout << np::asin(x) << '\n';
    return 0;
}
```

Output

```
[-1.5707963, 0, 0.52359878, 0.78539816, 1.0471976, 1.5707963]
```

`atan`

Return the principal value of the arc tangent, element-wise.
```cpp
template <class T>
array<T> atan(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose arc tangent is computed.

Returns

* A light-weight object with the arc tangent, in radians, of each value in the 
array. Convertible to an [`array`](1.%20Array.md) object.

`atan`

Return the principal value of the arc tangent, element-wise.
```cpp
template <class T>
matrix<T> atan(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose arc tangent is computed.

Returns

* A light-weight object with the arc tangent, in radians, of each value in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double inf = np::constants<double>::inf;
    double sqrt3 = np::sqrt(3);
    np::array<double> x{-inf, -sqrt3, -1, -1/sqrt3, 0, 1/sqrt3, 1, sqrt3, inf};
    std::cout << np::atan(x) << '\n';
    return 0;
}
```

Output

```
[-1.5707963, -1.0471976, -0.78539816, -0.52359878, 0, 0.52359878, 0.78539816, 
1.0471976, 1.5707963]
```

`atan2`

Return the principal value of the arc tangent of `y/x`, element-wise. To 
compute the value, the function takes into account the sign of both arguments 
in order to determine the quadrant.
```cpp
template <class T>
array<T> atan2(const array<T> &y, const array<T> &x);

template <class T>
array<T> atan2(const array<T> &y, const typename array<T>::value_type &x);

template <class T>
array<T> atan2(const typename array<T>::value_type &y, const array<T> &x);
```

Parameters

* `y` An array-like object with the y-coordinates.
* `x` An array-like object with the x-coordinates.

Returns

* A light-weight object with the arc tangent, in radians, of `y/x`. Convertible 
to an [`array`](1.%20Array.md) object.

`atan2`

Return the principal value of the arc tangent of `y/x`, element-wise. To 
compute the value, the function takes into account the sign of both arguments 
in order to determine the quadrant.
```cpp
template <class T>
matrix<T> atan2(const matrix<T> &y, const matrix<T> &x);

template <class T>
matrix<T> atan2(const matrix<T> &y, const typename matrix<T>::value_type &x);

template <class T>
matrix<T> atan2(const typename matrix<T>::value_type &y, const matrix<T> &x);
```

Parameters

* `y` A matrix-like object with the y-coordinates.
* `x` A matrix-like object with the x-coordinates.

Returns

* A light-weight object with the arc tangent, in radians, of `y/x`. Convertible 
to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double sqrt2 = np::sqrt(2);
    double sqrt3 = np::sqrt(3);
    np::array<double> x{1, sqrt3/2, 1/sqrt2, 0.5, 0, -0.5, -1/sqrt2, -sqrt3/2, -1};
    np::array<double> y{0, 0.5, 1/sqrt2, sqrt3/2, 1, sqrt3/2, 1/sqrt2, 0.5, 0};
    std::cout << np::atan2(y, x) << '\n';
    return 0;
}
```

Output

```
[0, 0.52359878, 0.78539816, 1.0471976, 1.5707963, 2.0943951, 2.3561945, 
2.6179939, 3.1415927]
```

`degrees`

Convert angles from radians to degrees.
```cpp
double degrees(double x);
float degrees(float x);
long double degrees(long double x);
template <class T>
double degrees(T x); // Additional overloads for integral types.
```

Parameters

* `x` Angle in radians.

Returns

* The corresponding angle in degrees.

`degrees`

Convert angles from radians to degrees, element-wise.
```cpp
template <class T>
array<T> degrees(const array<T> &x)
```

Parameters

* `x` An array-like object with the angles in radians.

Returns

* A light-weight object with the corresponding angles in degrees. Convertible 
to an [`array`](1.%20Array.md) object.

`degrees`

Convert angles from radians to degrees, element-wise.
```cpp
template <class T>
matrix<T> degrees(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the angles in radians.

Returns

* A light-weight object with the corresponding angles in degrees. Convertible 
to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double pi = np::constants<double>::pi;
    np::array<double> x{0, pi/6, pi/4, pi/3, pi/2, pi};
    std::cout << np::degrees(x) << '\n';
    return 0;
}
```

Output

```
[0, 30, 45, 60, 90, 180]
```

`radians`

Convert angles from degrees to radians.
```cpp
double radians(double x);
float radians(float x);
long double radians(long double x);
template <class T> 
double radians(T x); // Additional overloads for integral types.
```

Parameters

* `x` Angle in degrees.

Returns

* The corresponding angle in radians.

`radians`

Convert angles from degrees to radians, element-wise.
```cpp
template <class T>
array<T> radians(const array<T> &x);
```

Parameters

* `x` An array-like object with the angles in degrees.

Returns

* A light-weight object with the corresponding angles in radians. Convertible 
to an [`array`](1.%20Array.md) object.

`radians`

Convert angles from degrees to radians, element-wise.
```cpp
template <class T>
matrix<T> radians(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the angles in degrees.

Returns

* A light-weight object with the corresponding angles in radians. Convertible 
to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x{0, 30, 45, 60, 90, 180};
    std::cout << np::radians(x) << '\n';
    return 0;
}
```

Output

```
[0, 0.52359878, 0.78539816, 1.0471976, 1.5707963, 3.1415927]
```

## Hyperbolic functions

`cosh`

Return the hyperbolic cosine, element-wise.
```cpp
template <class T>
array<T> cosh(const array<T> &x);
```

Parameters

* `x` An array-like object with the hyperbolic angles.

Returns

* A light-weight object with the hyperbolic cosine of each element in the 
array. Convertible to an [`array`](1.%20Array.md) object.

`cosh`

Return the hyperbolic cosine, element-wise.
```cpp
template <class T>
matrix<T> cosh(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the hyperbolic angles.

Returns

* A light-weight object with the hyperbolic cosine of each element in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::cosh(x) << '\n';
    return 0;
}
```

Input

```
[-4, -3, -2, -1, 0, 1, 2, 3, 4]
```

Output

```
[27.308233, 10.067662, 3.7621957, 1.5430806, 1, 1.5430806, 3.7621957, 
10.067662, 27.308233]
```

`sinh`

Return the hyperbolic sine, element-wise.
```cpp
template <class T>
array<T> sinh(const array<T> &x);
```

Parameters

* `x` An array-like object with the hyperbolic angles.

Returns

* A light-weight object with the hyperbolic sine of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`sinh`

Return the hyperbolic sine, element-wise.
```cpp
template <class T>
matrix<T> sinh(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the hyperbolic angles.

Returns

* A light-weight object with the hyperbolic sine of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::sinh(x) << '\n';
    return 0;
}
```

Input

```
[-4, -3, -2, -1, 0, 1, 2, 3, 4]
```

Output

```
[-27.289917, -10.017875, -3.6268604, -1.1752012, 0, 1.1752012, 3.6268604, 
10.017875, 27.289917]
```

`tanh`

Return the hyperbolic tangent, element-wise.
```cpp
template <class T>
array<T> tanh(const array<T> &x);
```

Parameters

* `x` An array-like object with the hyperbolic angles.

Returns

* A light-weight object with the hyperbolic tangent of each element in the 
array. Convertible to an [`array`](1.%20Array.md) object.

`tanh`

Return the hyperbolic tangent, element-wise.
```cpp
template <class T>
matrix<T> tanh(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the hyperbolic angles.

Returns

* A light-weight object with the hyperbolic tangent of each element in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::tanh(x) << '\n';
    return 0;
}
```

Input

```
[-4, -3, -2, -1, 0, 1, 2, 3, 4]
```

Output

```
[-0.9993293, -0.99505475, -0.96402758, -0.76159416, 0, 0.76159416, 0.96402758, 
0.99505475, 0.9993293]
```

`acosh`

Return the inverse hyperbolic cosine, element-wise.
```cpp
template <class T>
array<T> acosh(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose inverse hyperbolic cosine is 
computed.

Returns

* A light-weight object with the inverse hyperbolic cosine of each element in 
the array. Convertible to an [`array`](1.%20Array.md) object.

`acosh`

Return the inverse hyperbolic cosine, element-wise.
```cpp
template <class T>
matrix<T> acosh(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose inverse hyperbolic cosine is 
computed.

Returns

* A light-weight object with the inverse hyperbolic cosine of each element in 
the matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::acosh(x) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8]
```

Output

```
[0, 1.3169579, 1.7627472, 2.0634371, 2.2924317, 2.4778887, 2.6339158, 
2.7686594]
```

`asinh`

Return the inverse hyperbolic sine, element-wise.
```cpp
template <class T>
array<T> asinh(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose inverse hyperbolic sine is 
computed.

Returns

* A light-weight object with the inverse hyperbolic sine of each element in 
the array. Convertible to an [`array`](1.%20Array.md) object.

`asinh`

Return the inverse hyperbolic sine, element-wise.
```cpp
template <class T>
matrix<T> asinh(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose inverse hyperbolic sine is 
computed.

Returns

* A light-weight object with the inverse hyperbolic sine of each element in 
the matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::asinh(x) << '\n';
    return 0;
}
```
Input

```
[-4, -3, -2, -1, 0, 1, 2, 3, 4]
```

Output

```
[-2.0947125, -1.8184465, -1.4436355, -0.88137359, 0, 0.88137359, 1.4436355, 
1.8184465, 2.0947125]
```

`atanh`

Return the inverse hyperbolic tangent, element-wise.
```cpp
template <class T>
array<T> atanh(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose inverse hyperbolic tangent is 
computed.

Returns

* A light-weight object with the inverse hyperbolic tangent of each element in 
the array. Convertible to an [`array`](1.%20Array.md) object.

`atanh`

Return the inverse hyperbolic tangent, element-wise.
```cpp
template <class T>
matrix<T> atanh(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose inverse hyperbolic tangent is 
computed.

Returns

* A light-weight object with the inverse hyperbolic tangent of each element in 
the matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::atanh(x) << '\n';
    return 0;
}
```

Input

```
[-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1]
```

Output

```
[-inf, -0.97295507, -0.54930614, -0.25541281, 0, 0.25541281, 0.54930614, 
0.97295507, inf]
```

## Exponential and logarithmic functions

`exp`

Return the base-e exponential, which is `e` raised to the power `x`: 
e<sup>x</sup>, element-wise.
```cpp
template <class T>
array<T> exp(const array<T> &x);
```

Parameters

* `x` An array-like object with the values of the exponents.

Returns

* A light-weight object with the exponential of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`exp`

Return the base-e exponential, which is `e` raised to the power `x`: 
e<sup>x</sup>, element-wise.
```cpp
template <class T>
matrix<T> exp(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values of the exponents.

Returns

* A light-weight object with the exponential of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::exp(x) << '\n';
    return 0;
}
```

Input

```
[-3, -2, -1, 0, 1, 2, 3, 4]
```

Output

```
[0.049787068, 0.13533528, 0.36787944, 1, 2.7182818, 7.3890561, 20.085537, 
54.59815]
```

`log`

Return the natural logarithm, which is the inverse of the exponential function 
(`exp`), element-wise.
```cpp
template <class T>
array<T> log(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose logarithm is computed.

Returns

* A light weight-object with the natural logarithm of each element in the 
array. Convertible to an [`array`](1.%20Array.md) object.

`log`

Return the natural logarithm, which is the inverse of the exponential function 
(`exp`), element-wise.
```cpp
template <class T>
matrix<T> log(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose logarithm is computed.

Returns

* A light weight-object with the natural logarithm of each element in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::log(x) << '\n';
    return 0;
}
```

Input

```
[0.1, 0.5, 1, 2, 3, 4, 5, 6]
```

Output

```
[-2.3025851, -0.69314718, 0, 0.69314718, 1.0986123, 1.3862944, 1.6094379, 
1.7917595]
```

`log10`

Return the common (base-10) logarithm, element-wise.
```cpp
template <class T>
array<T> log10(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose logarithm is computed.

Returns

* A light-weight object with the common logarithm of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`log10`

Return the common (base-10) logarithm, element-wise.
```cpp
template <class T>
matrix<T> log10(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose logarithm is computed.

Returns

* A light-weight object with the common logarithm of each element in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::log10(x) << '\n';
    return 0;
}
```

Input

```
[0.001, 0.01, 0.1, 1, 10, 100, 1000, 10000]
```

Output

```
[-3, -2, -1, 0, 1, 2, 3, 4]
```

`exp2`

Return the base-2 exponential, which is 2 raised to the power `x`: 
2<sup>x</sup>, element-wise.
```cpp
template <class T>
array<T> exp2(const array<T> &x);
```

Parameters

* `x` An array-like object with the values of the exponents.

Returns

* A light-weight object with the base-2 exponential of each element in the 
array. Convertible to an [`array`](1.%20Array.md) object.

`exp2`

Return the base-2 exponential, which is 2 raised to the power `x`: 
2<sup>x</sup>, element-wise.
```cpp
template <class T>
matrix<T> exp2(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values of the exponents.

Returns

* A light-weight object with the base-2 exponential of each element in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::exp2(x) << '\n';
    return 0;
}
```

Input

```
[-3, -2, -1, 0, 1, 2, 3, 4]
```

Output

```
[0.125, 0.25, 0.5, 1, 2, 4, 8, 16]
```

`log2`

Return the binary (base-2) logarithm, element-wise.
```cpp
template <class T>
array<T> log2(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose logarithm is computed.

Returns

* A light-weight object with the binary logarithm of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`log2`

Return the binary (base-2) logarithm, element-wise.
```cpp
template <class T>
matrix<T> log2(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose logarithm is computed.

Returns

* A light-weight object with the binary logarithm of each element in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::log2(x) << '\n';
    return 0;
}
```

Input

```
[0.125, 0.25, 0.5, 1, 2, 4, 8, 16]
```

Output

```
[-3, -2, -1, 0, 1, 2, 3, 4]
```

`expm1`

Return `e` raised to the power `x` minus one: e<sup>x</sup> - 1, element-wise. 
For values of `x` close to zero, `expm1` is more accurate than `exp(x) - 1`.
```cpp
template <class T>
array<T> expm1(const array<T> &x);
```

Parameters

* `x` An array-like object with the values of the exponent.

Returns

* A light-weight object with the exponential minus one of each element in the 
array. Convertible to an [`array`](1.%20Array.md) object.

`expm1`

Return `e` raised to the power `x` minus one: e<sup>x</sup> - 1, element-wise.
For values of `x` close to zero, `expm1` is more accurate than `exp(x) - 1`.
```cpp
template <class T>
matrix<T> expm1(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values of the exponent.

Returns

* A light-weight object with the exponential minus one of each element in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::expm1(x) << '\n';
    return 0;
}
```

Input

```
[-3, -2, -1, 0, 1, 2, 3, 4]
```

Output

```
[-0.95021293, -0.86466472, -0.63212056, 0, 1.7182818, 6.3890561, 19.085537, 
53.59815]
```

`log1p`

Return the natural logarithm of one plus `x`, element-wise. For values of `x` 
close to zero, `log1p` is more accurate than `log(1 + x)`.
```cpp
template <class T>
array<T> log1p(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose logarithm is computed.

Returns

* A light-weight object with the natural logarithm of `(1 + x)` for each 
element in the array. Convertible to an [`array`](1.%20Array.md) object.

`log1p`

Return the natural logarithm of one plus `x`, element-wise. For values of `x` 
close to zero, `log1p` is more accurate than `log(1 + x)`.
```cpp
template <class T>
matrix<T> log1p(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose logarithm is computed.

Returns

* A light-weight object with the natural logarithm of `(1 + x)` for each 
element in the matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::log1p(x) << '\n';
    return 0;
}
```

Input

```
[0.1, 0.5, 1, 2, 3, 4, 5, 6]
```

Output

```
[0.09531018, 0.40546511, 0.69314718, 1.0986123, 1.3862944, 1.6094379, 
1.7917595, 1.9459101]
```

## Power functions

`pow`

Return `x` raised to the power `y`, element-wise.
```cpp
template <class T>
array<T> pow(const array<T> &x, const array<T> &y);

template <class T>
array<T> pow(const array<T> &x, const typename array<T>::value_type &y);

template <class T>
array<T> pow(const typename array<T>::value_type &x, const array<T> &y);
```

Parameters

* `x` An array-like object with the values of the base.
* `y` An array-like object with the values of the exponent.

Returns

* A light-weight object with the result of rasing `x` to the power `y`. 
Convertible to an [`array`](1.%20Array.md) object.

`pow`

Return `x `raised to the power `y`, element-wise.
```cpp
template <class T>
matrix<T> pow(const matrix<T> &x, const matrix<T> &y);

template <class T>
matrix<T> pow(const matrix<T> &x, const typename matrix<T>::value_type &y);

template <class T>
matrix<T> pow(const typename matrix<T>::value_type &x, const matrix<T> &y);
```

Parameters

* `x` A matrix-like object with the values of the base.
* `y` A matrix-like object with the values of the exponent.

Returns

* A light-weight object with the result of rasing `x` to the power `y`. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x, y;
    std::cin >> x >> y;
    std::cout << np::pow(x, y) << '\n';
    return 0;
}
```

Input

```
[2, 2, 2, 3, 3, 4, 5, 10, 100]
[2, 3, 4, 2, 3, 2, 2, -1, 0.5]
```

Output

```
[4, 8, 16, 9, 27, 16, 25, 0.1, 10]
```

`sqrt`

Return the square root, element-wise.
```cpp
template <class T>
array<T> sqrt(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose square root is computed.

Returns

* A light-weight object with the square root of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`sqrt`

Return the square root, element-wise.
```cpp
template <class T>
matrix<T> sqrt(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose square root is computed.

Returns

* A light-weight object with the square root of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::sqrt(x) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Output

```
[1, 1.4142136, 1.7320508, 2, 2.236068, 2.4494897, 2.6457513, 2.8284271, 3, 
3.1622777]
```

`cbrt`

Return the cubic root, element-wise.
```cpp
template <class T>
array<T> cbrt(const array<T> &x);
```

Parameters

* `x` An array-like object with the values whose cubic root is computed.

Returns

* A light-weight object with the cubic root of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`cbrt`

Return the cubic root, element-wise.
```cpp
template <class T>
matrix<T> cbrt(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values whose cubic root is computed.

Returns

* A light-weight object with the cubic root of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::cbrt(x) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Output

```
[1, 1.259921, 1.4422496, 1.5874011, 1.7099759, 1.8171206, 1.9129312, 2, 
2.0800838, 2.1544347]
```

## Rounding

`ceil`

Rounds `x` upward. Return the smallest integral value that is not less than 
`x`, element-wise.
```cpp
template <class T>
array<T> ceil(const array<T> &x);
```

Parameters

* `x` An array-like object with the values to round up.

Returns

* A light-weight object with the ceiling of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`ceil`

Rounds `x` upward. Return the smallest integral value that is not less than 
`x`, element-wise.
```cpp
template <class T>
matrix<T> ceil(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values to round up.

Returns

* A light-weight object with the ceiling of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::ceil(x) << '\n';
    return 0;
}
```

Input

```
[-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]
```

Output

```
[-2, -1, -1, -0, 0, 1, 1, 2, 2]
```

`floor`

Rounds `x` downward. Return the largest integral value that is not greater than 
`x`, element-wise.
```cpp
template <class T>
array<T> floor(const array<T> &x);
```

Parameters

* `x` An array-like object with the values to round down.

Returns

* A light-weight object with the floor of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`floor`

Rounds `x` downward. Return the largest integral value that is not greater than 
`x`, element-wise.
```cpp
template <class T>
matrix<T> floor(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values to round down.

Returns

* A light-weight object with the floor of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::floor(x) << '\n';
    return 0;
}
```

Input

```
[-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]
```

Output

```
[-2, -2, -1, -1, 0, 0, 1, 1, 2]
```

`trunc`

Rounds `x` toward zero. Return the nearest integral value that is not larger in 
magnitude than `x`, element-wise.
```cpp
template <class T>
array<T> trunc(const array<T> &x);
```

Parameters

* `x` An array-like object with the values to truncate.

Returns

* A light-weight object with the truncated value of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`trunc`

Rounds `x` toward zero. Return the nearest integral value that is not larger in 
magnitude than `x`, element-wise.
```cpp
template <class T>
matrix<T> trunc(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values to truncate.

Returns

* A light-weight object with the truncated value of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::trunc(x) << '\n';
    return 0;
}
```

Input

```
[-2, -1.5, -1, -0.5, 0, 0.5, 1, 1.5, 2]
```

Output

```
[-2, -1, -1, -0, 0, 0, 1, 1, 2]
```

`round`

Return the integral value that is nearest to `x`, element-wise. Halfway cases 
are rounded away from zero.
```cpp
template <class T>
array<T> round(const array<T> &x);
```

Parameters

* `x` An array-like object with the values to round.

Returns

* A light-weight object with the rounded value of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`round`

Return the integral value that is nearest to `x`, element-wise. Halfway cases 
are rounded away from zero.
```cpp
template <class T>
matrix<T> round(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with the values to round.

Returns

* A light-weight object with the rounded value of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    std::cout << np::round(x) << '\n';
    return 0;
}
```

Input

```
[-1, -0.75, -0.5, -0.25, 0, 0.25, 0.5, 0.75, 1]
```

Output

```
[-1, -1, -1, -0, 0, 0, 1, 1, 1]
```

## Floating-point manipulation functions

`frexp`

Descompose `x` into its binary significand and an integral power of two, such 
that x = significand * 2<sup>exponent</sup>, element-wise. The exponent is 
stored in the location pointed by `exp`, and the significand is the value 
returned by the function.
```cpp
template <class T>
array<T> frexp(const array<T> &x, array<int> &exp);
```

Parameters

* `x` An array-like object with the values to be decomposed.
* `exp` A reference to an array-like object where the values of the exponent 
will be stored.

Returns

* A light-weight object with the binary significand of each element in the 
array. Convertible to an [`array`](1.%20Array.md) object.

`frexp`

Descompose `x` into its binary significand and an integral power of two, such 
that x = significand * 2<sup>exponent</sup>, element-wise. The exponent is 
stored in the location pointed by `exp`, and the significand is the value 
returned by the function.
```cpp
template <class T>
matrix<T> frexp(const matrix<T> &x, matrix<int> &exp);
```

Parameters

* `x` A matrix-like object with the values to be decomposed.
* `exp` A reference to a matrix-like object where the values of the exponent 
will be stored.

Returns

* A light-weight object with the binary significand of each element in the 
matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    std::cin >> x;
    np::array<int> exp(x.size());
    std::cout << "mantissa: " << np::frexp(x, exp) << '\n';
    std::cout << "exponent: " << exp << '\n';
    return 0;
}
```

Input

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Output

```
mantissa: [0, 0.5, 0.5, 0.75, 0.5, 0.625, 0.75, 0.875, 0.5, 0.5625]
exponent: [0, 1, 2, 2, 3, 3, 3, 3, 4, 4]
```

`ldexp`

Return the result of multiplying `x` (the significand) by 2 raised to the power of `exp` (the exponent), element-wise.
```cpp
template <class T>
array<T> ldexp(const array<T> &x, const array<int> &exp);

template <class T>
array<T> ldexp(const array<T> &x, const typename array<int>::value_type &exp);

template <class T>
array<T> ldexp(const typename array<T>::value_type &x, const array<int> &exp);
```

Parameters

* `x` An array-like object with the values of the significand.
* `exp` An array-like object with the values of the exponent.

Returns

* A light-weight object with the result of x * 2<sup>exp</sup> for each element 
in the array. Convertible to an [`array`](1.%20Array.md) object.

`ldexp`

Return the result of multiplying `x` (the significand) by 2 raised to the power 
of `exp` (the exponent), element-wise.
```cpp
template <class T>
matrix<T> ldexp(const matrix<T> &x, const matrix<int> &exp);

template <class T>
matrix<T> ldexp(const matrix<T> &x, const typename matrix<int>::value_type &exp);

template <class T>
matrix<T> ldexp(const typename matrix<T>::value_type &x, const matrix<int> &exp);
```

Parameters

* `x` A matrix-like object with the values of the significand.
* `exp` A matrix-like object with the values of the exponent.

Returns

* A light-weight object with the result of x * 2<sup>exp</sup> for each element 
in the matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x;
    np::array<int> exp;
    std::cin >> x >> exp;
    std::cout << np::ldexp(x, exp) << '\n';
    return 0;
}
```

Input

```
[0, 0.5, 0.5, 0.75, 0.5, 0.625, 0.75, 0.875, 0.5, 0.5625]
[0, 1, 2, 2, 3, 3, 3, 3, 4, 4]
```

Output

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

`copysign`

Return a value with the magnitude of `x` and the sign of `y`, element-wise.
```cpp
template <class T>
array<T> copysign(const array<T> &x, const array<T> &y);

template <class T>
array<T> copysign(const array<T> &x, const typename array<T>::value_type &y);
```

Parameters

* `x` An array-like object with the values to change the sign of.
* `y` An array-like object with the values to copy the sign from.

Returns

* A light-weight object with the values in the first array and the signs in the 
second array. Convertible to an [`array`](1.%20Array.md) object.

`copysign`

Return a value with the magnitude of `x` and the sign of `y`, element-wise.
```cpp
template <class T>
matrix<T> copysign(const matrix<T> &x, const matrix<T> &y);

template <class T>
matrix<T> copysign(const matrix<T> &x, const typename matrix<T>::value_type &y);
```

Parameters

* `x` A matrix-like object with the values to change the sign of.
* `y` A matrix-like object with the values to copy the sign from.

Returns

* A light-weight object with the values in the first matrix and the signs in 
the second matrix. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x, y;
    std::cin >> x >> y;
    std::cout << np::copysign(x, y) << '\n';
    return 0;
}
```

Input

```
[5, 3, -1, 0, 2, 8, 10, -7]
[1, -1, 1, 1, 1, -1, -1, -1]
```

Output

```
[5, -3, 1, 0, 2, -8, -10, -7]
```

`nextafter`

Return the next representable value after `x` in the direction of `y`,
element-wise.
```cpp
template <class T>
array<T> nextafter(const array<T> &x, const array<T> &y);

template <class T>
array<T> nextafter(const array<T> &x, const typename array<T>::value_type &y);
```

Parameters

* `x` An array-like object with the base values.
* `y` An array-like object with the directions where to look for the next 
representable values.

Returns

* A light-weight object with the next representable value of each element in 
the first array in the direction of the second array. Convertible to an 
[`array`](1.%20Array.md) object.

`nextafter`

Return the next representable value after `x` in the direction of `y`, 
element-wise.
```cpp
template <class T>
matrix<T> nextafter(const matrix<T> &x, const matrix<T> &y);

template <class T>
matrix<T> nextafter(const matrix<T> &x, const typename matrix<T>::value_type &y);
```

Parameters

* `x` A matrix-like object with the base values.
* `y` A matrix-like object with the directions where to look for the next 
representable values.

Returns

* A light-weight object with the next representable value of each element in 
the first matrix in the direction of the second matrix. Convertible to a 
[`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x, y;
    std::cin >> x >> y;
    np::printoptions::precision = np::printoptions::fullprecision;
    std::cout << np::nextafter(x, y) << '\n';
    return 0;
}
```

Example

```
[-2, -2, -1, -1, 0, 0, 1, 1, 2, 2]
[-3, -1, -2, 0, -1, 1, 0, 2, 1, 3]
```

Output

```
[-2.0000000000000004, -1.9999999999999998, -1.0000000000000002, 
-0.99999999999999989, -4.9406564584124654e-324, 4.9406564584124654e-324, 
0.99999999999999989, 1.0000000000000002, 1.9999999999999998, 
2.0000000000000004]
```

## Integer-valued functions

`gcd`

Return the greatest common divisor of `|m|` and `|n|`.
```cpp
template <class T1, class T2>
typename std::common_type<T1, T2>::type gcd(T1 m, T2 n);
```

Parameters

* `m` An integer value.
* `n` An integer value.

Returns

* The greatest common divisor of `|m|` and `|n|`. If both `m` and `n` are zero, 
return zero.

`gcd`

Return the greatest common divisor, element-wise.
```cpp
template <class T>
array<T> gcd(const array<T> &m, const array<T> &n);

template <class T>
array<T> gcd(const array<T> &m, const typename array<T>::value_type &n);

template <class T>
array<T> gcd(const typename array<T>::value_type &m, const array<T> &n);
```

Parameters

* `m` An array-like object with integer values.
* `n` An array-like object with integer values.

Returns

* A light-weight object with the greatest common divisor of `|m|` and `|n|`. If 
both `m` and `n` are zero, return zero. Convertible to an 
[`array`](1.%20Array.md) object.

`gcd`

Return the greatest common divisor, element-wise.
```cpp
template <class T>
matrix<T> gcd(const matrix<T> &m, const matrix<T> &n);

template <class T>
matrix<T> gcd(const matrix<T> &m, const typename matrix<T>::value_type &n);

template <class T>
matrix<T> gcd(const typename matrix<T>::value_type &m, const matrix<T> &n);
```

Parameters

* `m` A matrix-like object with integer values.
* `n` A matrix-like object with integer values.

Returns

* A light-weight object with the greatest common divisor of `|m|` and `|n|`. If 
both `m` and `n` are zero, return zero. Convertible to a 
[`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> m, n;
    std::cin >> m >> n;
    std::cout << np::gcd(m, n) << '\n';
    return 0;
}
```

Input

```
[24, 36, 45, 20, 20, 120, 10, 0]
[20, 40, 75, 18, 19, 100, 0, 0]
```

Output

```
[4, 4, 15, 2, 1, 20, 10, 0]
```

`lcm`

Return the least common multiple of `|m|` and `|n|`.
```cpp
template <class T1, class T2>
typename std::common_type<T1, T2>::type lcm(T1 m, T2 n);
```

Parameters

* `m` An integer value.
* `n` An integer value.

Returns

* The least common multiple of `|m|` and `|n|`. If either `m` or `n` is zero, 
return zero.

`lcm`

Return the least common multiple, element-wise.
```cpp
template <class T>
array<T> lcm(const array<T> &m, const array<T> &n);

template <class T>
array<T> lcm(const array<T> &m, const typename array<T>::value_type &n);

template <class T>
array<T> lcm(const typename array<T>::value_type &m, const array<T> &n);
```

Parameters

* `m` An array-like object with integer values.
* `n` An array-like object with integer values.

Returns

* A light-weight object with the least common multiple of `|m|` and `|n|`. If 
either `m` or `n` is zero, return zero. Convertible to an 
[`array`](1.%20Array.md) object.

`lcm`

Return the least common multiple, element-wise.

Parameters

* `m` A matrix-like object with integer values.
* `n` A matrix-like object with integer values.

Returns

* A light-weight object with the least common multiple of `|m|` and `|n|`. If 
either `m` or `n` is zero, return zero. Convertible to a 
[`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> m, n;
    std::cin >> m >> n;
    std::cout << np::lcm(m, n) << '\n';
    return 0;
}
```


Input

```
[24, 36, 45, 20, 20, 120, 10, 0]
[20, 40, 75, 18, 19, 100, 0, 0]
```

Output

```
[120, 360, 225, 180, 380, 600, 0, 0]
```

## Complex numbers

`real`

Return the real part, element-wise.
```cpp
template <class T>
array<T> real(const array< std::complex<T> > &z);

template <class T>
array<T> real(const array<T> &z);
```

Parameters

* `z` An array-like object with complex values.

Returns

* A light-weight object with the real part of each element in the array. If `T` 
is not a complex type, return the elements unchanged. Convertible to an 
[`array`](1.%20Array.md) object.

`real`

Return the real part, element-wise.
```cpp
template <class T>
matrix<T> real(const matrix< std::complex<T> > &z);

template <class T>
matrix<T> real(const matrix<T> &z);
```

Parameters

* `z` A matrix-like object with complex values.

Returns

* A light-weight object with the real part of each element in the matrix. If 
`T` is not a complex type, return the elements unchanged. Convertible to a 
[`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<std::complex<double>> z;
    std::cin >> z;
    std::cout << np::real(z) << '\n';
    return 0;
}
```

Input

```
[(1,7), (-9,8), (5,12), (10,0), (-2,3), (0,1), (3,4)]
``` 

Output

```
[1, -9, 5, 10, -2, 0, 3]
```

`imag`

Return the imaginary part, element-wise.
```cpp
template <class T>
array<T> imag(const array< std::complex<T> > &z);

template <class T>
array<T> imag(const array<T> &z);
```

Parameters

* `z` An array-like object with complex values.

Returns

* A light-weight object with the imaginary part of each element in the array. 
If `T` is not a complex type, return an array of zeros. Convertible to an 
[`array`](1.%20Array.md) object.

`imag`

Return the imaginary part, element-wise.

Parameters

* `z` A matrix-like object with complex values.

Returns

* A light-weight object with the imaginary part of each element in the matrix. 
If `T` is not a complex type, return a matrix of zeros. Convertible to a 
[`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<std::complex<double>> z;
    std::cin >> z;
    std::cout << np::imag(z) << '\n';
    return 0;
}
```

Input

```
[(1,7), (-9,8), (5,12), (10,0), (-2,3), (0,1), (3,4)]
``` 

Output

```
[7, 8, 12, 0, 3, 1, 4]
```

`abs`

Return the absolute value, element-wise.
```cpp
template <class T>
array<T> abs(const array< std::complex<T> > &z);
```

Parameters

* `z` An array-like object with the values whose absolute value is computed.

Returns

* A light-weight object with the absolute value of each element in the array. 
Convertible to an [`array`](1.%20Array.md) object.

`abs`

Return the absolute value, element-wise.
```cpp
template <class T>
matrix<T> abs(const matrix< std::complex<T> > &z);
```

Parameters

* `z` A matrix-like object with the values whose absolute value is computed.

Returns

* A light-weight object with the absolute value of each element in the matrix. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<std::complex<double>> z;
    std::cin >> z;
    std::cout << np::abs(z) << '\n';
    return 0;
}
```

Input

```
[(1,7), (-9,8), (5,12), (10,0), (-2,3), (0,1), (3,4)]
``` 

Output

```
[7.0710678, 12.041595, 13, 10, 3.6055513, 1, 5]
```

`arg`

Return the phase angle (in radians) of a complex number, element-wise.
```cpp
template <class T>
array<T> arg(const array< std::complex<T> > &z);

template <class T>
array<T> arg(const array<T> &z);
```

Parameters

* `z` An array-like object with the values whose phase angle is computed.

Returns

* A light-weight object with the phase angle of each element in the array. 
If `T` is not a complex type, the function assumes the value has a zero 
imaginary part. Convertible to an [`array`](1.%20Array.md) object.

`arg`

Return the phase angle (in radians) of a complex number, element-wise.
```cpp
template <class T>
matrix<T> arg(const matrix< std::complex<T> > &z);

template <class T>
matrix<T> arg(const matrix<T> &z);
```

Parameters

* `z` A matrix-like object with the values whose phase angle is computed.

Returns

* A light-weight object with the phase angle of each element in the matrix. 
If `T` is not a complex type, the function assumes the value has a zero 
imaginary part. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double sqrt2 = np::sqrt(2);
    double sqrt3 = np::sqrt(3);
    np::array<std::complex<double>> z{{1, 0}, {sqrt3/2, 0.5}, {1/sqrt2, 1/sqrt2},
                                      {0.5, sqrt3/2}, {0, 1}, {-0.5, sqrt3/2}, 
                                      {-1/sqrt2, 1/sqrt2}, {-sqrt3/2, 0.5}, {-1, 0}};
    std::cout << np::arg(z) << '\n';
    return 0;
}
```

Output

```
[0, 0.52359878, 0.78539816, 1.0471976, 1.5707963, 2.0943951, 2.3561945, 
2.6179939, 3.1415927]
```

`conj`

Return the complex conjugate, element-wise. The complex conjugate of a complex 
number is obtained by changing the sign of its imaginary part.
```cpp
template <class T>
array<T> conj(const array< std::complex<T> > &z);

template <class T>
array<T> conj(const array<T> &z);
```

Parameters

* `z` An array-like object with the values whose complex conjugate is computed.

Returns

* A light-weight object with the complex conjugate of each element in the 
array. If `T` is not a complex type, return the elements unchanged. Convertible 
to an [`array`](1.%20Array.md) object.

`conj`

Return the complex conjugate, element-wise. The complex conjugate of a complex 
number is obtained by changing the sign of its imaginary part. 
```cpp
template <class T>
matrix<T> conj(const matrix< std::complex<T> > &z);

template <class T>
matrix<T> conj(const matrix<T> &z);
```

Parameters

* `z` A matrix-like object with the values whose complex conjugate is computed.

Returns

* A light-weight object with the complex conjugate of each element in the 
matrix. If `T` is not a complex type, return the elements unchanged. 
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<std::complex<double>> z;
    std::cin >> z;
    std::cout << np::conj(z) << '\n';
    return 0;
}
```


Input

```
[(1,7), (-9,8), (5,12), (10,0), (-2,3), (0,1), (3,4)]
``` 

Output

```
[(1,-7), (-9,-8), (5,-12), (10,-0), (-2,-3), (0,-1), (3,-4)]
```

## Classification functions

`isfinite`

Return whether `x` is a finite value (neither infinite nor NaN), element-wise. 
```cpp
template <class T>
array<bool> isfinite(const array<T> &x);
```

Parameters

* `x` An array-like object with floating point values.

Returns

* A light-weight object with each element set to `true` where `x` is finite and 
`false` otherwise. Convertible to an [`array`](1.%20Array.md) object.

`isfinite`

Return whether `x` is a finite value (neither infinite nor NaN), element-wise. 
```cpp
template <class T>
matrix<bool> isfinite(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with floating point values.

Returns

* A light-weight object with each element set to `true` where `x` is finite and 
`false` otherwise. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x{0., 0./0., 1., -1., np::sqrt(-1.), 1./0., -1./0.};
    std::cout << np::isfinite(x) << '\n';
    return 0;
}
```

Output

```
[1, 0, 1, 1, 0, 0, 0]
```

`isinf`

Return whether `x` is an infinity value (either positive infinity or negative 
infinity), element-wise. 
```cpp
template <class T>
array<bool> isinf(const array<T> &x);
```

Parameters

* `x` An array-like object with floating point values.

Returns

* A light-weight object with each element set to `true` where `x` is infinity 
and `false` otherwise. Convertible to an [`array`](1.%20Array.md) object.

`isinf`

Return whether `x` is an infinity value (either positive infinity or negative 
infinity), element-wise. 
```cpp
template <class T>
matrix<bool> isinf(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with floating point values.

Returns

* A light-weight object with each element set to `true` where `x` is infinity 
and `false` otherwise. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x{0., 0./0., 1., -1., np::sqrt(-1.), 1./0., -1./0.};
    std::cout << np::isinf(x) << '\n';
    return 0;
}
```

Output

```
[0, 0, 0, 0, 0, 1, 1]
```

`isnan`

Return whether `x` is a NaN (Not a Number) value, element-wise. The NaN values 
are used to identify undefined or non-representable values for floating-point 
numbers, such as the square root of negative numbers or the result of 0/0.
```cpp
template <class T>
array<bool> isnan(const array<T> &x);
```

Parameters

* `x` An array-like object with floating point values.

Returns

* A light-weight object with each element set to `true` where `x` is NaN and 
`false` otherwise. Convertible to an [`array`](1.%20Array.md) object.

`isnan`

Return whether `x` is a NaN (Not a Number) value, element-wise. The NaN values 
are used to identify undefined or non-representable values for floating-point 
numbers, such as the square root of negative numbers or the result of 0/0.
```cpp
template <class T>
matrix<bool> isnan(const matrix<T> &x);
```

Parameters

* `x` A matrix-like object with floating point values.

Returns

* A light-weight object with each element set to `true` where `x` is NaN and 
`false` otherwise. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> x{0., 0./0., 1., -1., np::sqrt(-1.), 1./0., -1./0.};
    std::cout << np::isnan(x) << '\n';
    return 0;
}
```

Output

```
[0, 1, 0, 0, 1, 0, 0]
```
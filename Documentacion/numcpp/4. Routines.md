# Routines

Defined in: `numcpp/routines.h`

## Content

- [Routines](#routines)
  - [Content](#content)
  - [Array and matrix creation routines](#array-and-matrix-creation-routines)
  - [Numerical ranges](#numerical-ranges)
  - [Building matrices](#building-matrices)
  - [Maximums and minimums](#maximums-and-minimums)
  - [Sums and products](#sums-and-products)
  - [Concatenation](#concatenation)
  - [Padding](#padding)
  - [Insertion-deletion](#insertion-deletion)
  - [Logic functions](#logic-functions)
  - [Sorting and searching](#sorting-and-searching)
  - [Basic statistics](#basic-statistics)
  - [Basic linear algebra](#basic-linear-algebra)
  - [Set operations](#set-operations)

## Array and matrix creation routines

`empty`

Return a new array of given size without initializing entries.
```cpp
template <class T>
array<T> empty(size_t n);
```

Parameters

* `n` Length of array.

Returns

* An array of uninitialized data with the given size.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

`empty`

Return a new matrix of given size without initializing entries.
```cpp
template <class T>
matrix<T> empty(size_t m, size_t n);
```

Parameters

* `m` Number of rows.
* `n` Number of columns.

Returns

* A matrix of uninitialized data with the given size.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr = np::empty<int>(5);
    np::matrix<int> mat = np::empty<int>(2, 3);
    std::cout << arr << '\n' << mat << '\n';
    return 0;
}
```

Possible output

```
[-117412000, 384, -117440176, 384, 0]
[[-117412000,        384, -117440176],
 [       384, -117412000,        384]]
```

`empty_like`

Return a new array with the same size and type as a given array.
```cpp
template <class T>
array<T> empty_like(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* An array of uninitialized data with the same size and type as `arr`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

`empty_like`

Return a new matrix with the same size and type as a given matrix.
```cpp
template <class T>
matrix<T> empty_like(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* A matrix of uninitialized data with the same size and type as `mat`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1{1, 2, 3, 4, 5};
    np::matrix<int> mat1{{1, 2, 3}, {4, 5, 6}};
    np::array<int> arr2 = np::empty_like(arr1);
    np::matrix<int> mat2 = np::empty_like(mat1);
    std::cout << arr2 << '\n' << mat2 << '\n';
    return 0;
}
```

Output

```
[1081414512, 498, 1081409872, 498, 0]
[[1081414512,        498, 1081409872],
 [       498, 1081414512,        498]]
```

`zeros`

Return a new array of given size filled with zeros.
```cpp
template <class T>
array<T> zeros(size_t n);
```

Parameters

* `n` Length of array.

Returns

* An array of zeros with the given size.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

`zeros`

Return a new matrix of given size filled with zeros.
```cpp
template <class T>
matrix<T> zeros(size_t m, size_t n);
```

Parameters

* `m` Number of rows.
* `n` Number of columns.

Returns

* A matrix of zeros with the size size.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr = np::zeros<int>(5);
    np::matrix<int> mat = np::zeros<int>(2, 3);
    std::cout << arr << '\n' << mat << '\n';
    return 0;
}
```

Output

```
[0, 0, 0, 0, 0]
[[0, 0, 0],
 [0, 0, 0]]
```

`zeros_like`

Return a new array of zeros with the same size and type as a given array.
```cpp
template <class T>
array<T> zeros_like(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* An array of zeros with the same size and type as `arr`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

`zeros_like`

Return a new matrix of zeros with the same size and type as a given matrix.
```cpp
template <class T>
matrix<T> zeros_like(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* A matrix of zeros with the same size and type as `mat`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1{1, 2, 3, 4, 5};
    np::matrix<int> mat1{{1, 2, 3}, {4, 5, 6}};
    np::array<int> arr2 = np::zeros_like(arr1);
    np::matrix<int> mat2 = np::zeros_like(mat1);
    std::cout << arr2 << '\n' << mat2 << '\n';
    return 0;
}
```

Output

```
[0, 0, 0, 0, 0]
[[0, 0, 0],
 [0, 0, 0]]
```

`ones`

Return a new array of given size filled with ones.
```cpp
template <class T>
array<T> ones(size_t n);
```

Parameters

* `n` Length of array.

Returns

* An array of ones with the given size.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

`ones`

Return a new matrix of given size filled with ones.
```cpp
template <class T>
matrix<T> ones(size_t m, size_t n);
```

Parameters

* `m` Number of rows.
* `n` Number of columns.

Returns

* A matrix of ones with the given size.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr = np::ones<int>(5);
    np::matrix<int> mat = np::ones<int>(2, 3);
    std::cout << arr << '\n' << mat << '\n';
    return 0;
}
```

Output

```
[1, 1, 1, 1, 1]
[[1, 1, 1],
 [1, 1, 1]]
```

`ones_like`

Return a new array of ones with the same size and type as a given array.
```cpp
template <class T>
array<T> ones_like(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* An array of ones with the same size and type as `arr`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

`ones_like`

Return a new matrix of ones with the same size and type as a given matrix.
```cpp
template <class T>
matrix<T> ones_like(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* A matrix of ones with the same size and type as `mat`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1{1, 2, 3, 4, 5};
    np::matrix<int> mat1{{1, 2, 3}, {4, 5, 6}};
    np::array<int> arr2 = np::ones_like(arr1);
    np::matrix<int> mat2 = np::ones_like(mat1);
    std::cout << arr2 << '\n' << mat2 << '\n';
    return 0;
}
```

Output

```
[1, 1, 1, 1, 1]
[[1, 1, 1],
 [1, 1, 1]]
```

`full`

Return a new array of given size filled with `val`.
```cpp
template <class T>
array<T> full(size_t n, const T &val);
```

Parameters

* `n` Length of array.
* `val` Fill value.

Returns

* An array of `val` with the given size.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

`full`

Return a new matrix of given size filled with `val`.
```cpp
template <class T>
matrix<T> full(size_t m, size_t n, const T &val);
```

Parameters

* `m` Number of rows.
* `n` Number of columns.
* `val` Fill value.

Returns

* A matrix of `val` with the given size.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr = np::full<int>(5, 10);
    np::matrix<int> mat = np::full<int>(2, 3, 10);
    std::cout << arr << '\n' << mat << '\n';
    return 0;
}
```

Output

```
[10, 10, 10, 10, 10]
[[10, 10, 10],
 [10, 10, 10]]
```

`full_like`

Return a new array of `val` with the same size and type as a given array.
```cpp
template <class T>
array<T> full_like(const array<T> &arr, const typename array<T>::value_type &val);
```

Parameters

* `arr` An array-like object.
* `val` Fill value.

Returns

* An array of `val` with the same size and type as `arr`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

`full_like`

Return a new matrix of `val` with the same size and type as a given matrix.
```cpp
template <class T>
matrix<T> full_like(const matrix<T> &mat, const typename matrix<T>::value_type &val);
```

Parameters

* `mat` A matrix-like object.
* `val` Fill value.

Returns

* A matrix of `val` with the same size and type as `mat`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1{1, 2, 3, 4, 5};
    np::matrix<int> mat1{{1, 2, 3}, {4, 5, 6}};
    np::array<int> arr2 = np::full_like(arr1, 10);
    np::matrix<int> mat2 = np::full_like(mat1, 10);
    std::cout << arr2 << '\n' << mat2 << '\n';
    return 0;
}
```

Output

```
[10, 10, 10, 10, 10]
[[10, 10, 10],
 [10, 10, 10]]
```

## Numerical ranges

`arange`

Return evenly spaced values within a given interval. Values are generated 
within the half-open interval [`start`, `stop`), i.e., the interval including 
`start` but excluding `stop`.
```cpp
template <class T>
array<T> arange(const T &stop);

template <class T>
array<T> arange(const T &start, const T &stop);

template <class T>
array<T> arange(const T &start, const T &stop, const T &step);
```

Parameters

* `start` Start of interval. Defaults to 0 if not provided.
* `stop` End of interval. 
* `step` Spacing between values. This is the distance between two adjacent 
values. Defaults to 1 if not provided.

Returns

* A light-weight object with evenly spaced values. Convertible to an `array` 
object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr = np::arange<int>(10);
    std::cout << arr << '\n';
    arr = np::arange<int>(11, 21);
    std::cout << arr << '\n';
    arr = np::arange<int>(1, 20, 3);
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]
[1, 4, 7, 10, 13, 16, 19]
```

`linspace`

Return evenly spaced numbers over a specified interval. Return `num` evenly 
spaced samples, calculated over the interval [`start`, `stop`]. The endpoint of 
the interval can optionally be excluded.
```cpp
template <class T>
array<T> linspace(
    const T &start, const T &stop, size_t num = 50, bool endpoint = true
);
```

Parameters

* `start` The starting value of the sequence.
* `stop` The end value of the sequence. 
* `num` Number of samples to generate. Default is 50.
* `endpoint` If `true`, `stop` is the last sample. Otherwise, it is not included. 
Default is `true`.

Returns

* A light-weight object with equally spaced samples. Convertible to an `array` 
object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr = np::linspace<double>(0, 1, 10);
    std::cout << arr << '\n';
    arr = np::linspace<double>(0, 1, 10, false);
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[0, 0.11111111, 0.22222222, 0.33333333, 0.44444444, 0.55555556, 0.66666667, 
0.77777778, 0.88888889, 1]
[0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]
```

`logspace`

Return numbers spaced evenly on a log scale. In linear space, the sequence 
starts at `pow(base, start)` (base to the power of start) and ends with 
`pow(base, stop)`.
```cpp
template <class T>
array<T> logspace(
    const T &start, const T &stop, size_t num = 50, bool endpoint = true,
    const T &base = T(10)
);
```

Parameters

* `start` `pow(base, stop)` is the starting value of the sequence.
* `stop` `pow(base, stop)` is the final value of the sequence. 
* `num` Number of samples to generate. Default is 50.
* `endpoint` If `true`, `stop` is the last sample. Otherwise, it is not 
included. Default is `true`.
* `base` The base of the log space. Default is 10.

Returns

* A light-weight object with equally spaced samples on a log scale. Convertible 
to an `array` object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr = np::logspace<double>(0, 9, 10);
    std::cout << arr << '\n';
    arr = np::logspace<double>(0, 9, 10, false);
    std::cout << arr << '\n';
    arr = np::logspace<double>(0, 9, 10, true, 2);
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 1e+08, 1e+09]
[1, 7.9432823, 63.095734, 501.18723, 3981.0717, 31622.777, 251188.64, 1995262.3, 
15848932, 1.2589254e+08]
[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]
```

`geomspace`

Return numbers spaced evenly on a log scale (a geometric progression). This is 
similar to logspace, but with endpoints specified directly. Each output sample 
is a constant multiple of the previous.
```cpp
template <class T>
array<T> geomspace(
    const T &start, const T &stop, size_t num = 50, bool endpoint = true
);
```

Parameters

* `start` The starting value of the sequence.
* `stop` The final value of the sequence.
* `num` Number of samples to generate. Default is 50.
* `endpoint` If `true`, `stop` is the last sample. Otherwise, it is not 
included. Default is `true`.

Returns

* A light-weight object with equally spaced samples on a log scale. Convertible 
to an `array` object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr = np::geomspace<double>(2, 1024, 10);
    std::cout << arr << '\n';
    arr = np::geomspace<double>(2, 1024, 10, false);
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]
[2, 3.732132, 6.9644045, 12.996038, 24.251465, 45.254834, 84.448506, 157.58648, 
294.06678, 548.74801]
```

## Building matrices

`diagonal`

Return a matrix with given values on the diagonal and zeros elsewhere.
```cpp
template <class T>
matrix<T> diagonal(const array<T> &arr, ptrdiff_t offset = 0);
```

Parameters

* `arr` An array-like object with the elements on the diagonal.
* `offset` Offset of the diagonal from the main diagonal. A positive value 
refers to an upper diagonal and a negative value refers to a lower diagonal. 
Defaults to main diagonal (0).

Returns

* A light-weight object with the given values on the diagonal and zeros 
elsewhere. Convertible to a `matrix` object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << "Main diagonal:\n" << np::diagonal(arr) << '\n';
    std::cout << "Subdiagonal:\n" << np::diagonal(arr, -1) << '\n';
    std::cout << "Superdiagonal:\n" << np::diagonal(arr, 1) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4]
```

Output

```
Main diagonal:
[[1, 0, 0, 0],
 [0, 2, 0, 0],
 [0, 0, 3, 0],
 [0, 0, 0, 4]]
Subdiagonal:
[[0, 0, 0, 0, 0],
 [1, 0, 0, 0, 0],
 [0, 2, 0, 0, 0],
 [0, 0, 3, 0, 0],
 [0, 0, 0, 4, 0]]
Superdiagonal:
[[0, 1, 0, 0, 0],
 [0, 0, 2, 0, 0],
 [0, 0, 0, 3, 0],
 [0, 0, 0, 0, 4],
 [0, 0, 0, 0, 0]]
```

`diagonal`

Return the diagonal of a matrix.
```cpp
template <class T>
array<T> diagonal(const matrix<T> &mat, ptrdiff_t offset = 0);
```

Parameters

* `mat` A matrix-like object from which the diagonal is taken.
* `offset` Offset of the diagonal from the main diagonal. A positive value 
refers to an upper diagonal and a negative value refers to a lower diagonal. 
Defaults to main diagonal (0).

Returns

* A light-weight object with the elements on the diagonal. Convertible to an 
`array` object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Main diagonal: " << np::diagonal(mat) << '\n';
    std::cout << "Subdiagonal: " << np::diagonal(mat, -1) << '\n';
    std::cout << "Superdiagonal: " << np::diagonal(mat, 1) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1],
 [-3, 5, 0, -7]]
```

Output

```
Main diagonal: [1, -2, 3, -7]
Subdiagonal: [10, 12, 0]
Superdiagonal: [-9, 7, -1]
```

`eye`

Return a matrix with ones on the diagonal and zeros elsewhere.
```cpp
template <class T>
matrix<T> eye(size_t n);

template <class T>
matrix<T> eye(size_t m, size_t n, ptrdiff_t offset = 0);
```

Parameters

* `m` Number of rows. If not provided, defaults to `n`.
* `n` Number of columns.
* `offset` Offset of the diagonal from the main diagonal. A positive value 
refers to an upper diagonal and a negative value refers to a lower diagonal. 
Defaults to main diagonal (0).

Returns

* A light-weight object with ones on the diagonal and zeros elsewhere. 
Convertible to a `matrix` object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat = np::eye<int>(4);
    std::cout << mat << '\n';
    mat = np::eye<int>(4, 6);
    std::cout << mat << '\n';
    mat = np::eye<int>(4, 4, 1);
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[1, 0, 0, 0],
 [0, 1, 0, 0],
 [0, 0, 1, 0],
 [0, 0, 0, 1]]
[[1, 0, 0, 0, 0, 0],
 [0, 1, 0, 0, 0, 0],
 [0, 0, 1, 0, 0, 0],
 [0, 0, 0, 1, 0, 0]]
[[0, 1, 0, 0],
 [0, 0, 1, 0],
 [0, 0, 0, 1],
 [0, 0, 0, 0]]
```

`tril`

Return the lower triangle portion of a matrix.
```cpp
template <class T>
matrix<T> tril(const matrix<T> &mat, ptrdiff_t offset = 0);
```

Parameters

* `mat` A matrix-like object from which to extract the lower triangle. 
* `offset` Diagonal above which to zero elements. A positive value refers to an 
upper diagonal and a negative value refers to a lower diagonal. Defaults to 
main diagonal (0).

Returns

* A light-weight object with the lower triangle of the matrix. Convertible to a 
matrix object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::tril(mat) << '\n';
    std::cout << np::tril(mat, -1) << '\n';
    std::cout << np::tril(mat, 1) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1],
 [-3, 5, 0, -7]]
```

Output

```
[[ 1,  0,  0,  0],
 [10, -2,  0,  0],
 [ 0, 12,  3,  0],
 [-3,  5,  0, -7]]
[[ 0,  0,  0,  0],
 [10,  0,  0,  0],
 [ 0, 12,  0,  0],
 [-3,  5,  0,  0]]
[[ 1, -9,  0,  0],
 [10, -2,  7,  0],
 [ 0, 12,  3, -1],
 [-3,  5,  0, -7]]
```

`triu`

Return the upper triangle portion of a matrix.
```cpp
template <class T>
matrix<T> triu(const matrix<T> &mat, ptrdiff_t offset = 0);
```

Parameters

* `mat` A matrix-like object from which to extract the upper triangle. 
* `offset` Diagonal below which to zero elements. A positive value refers to an 
upper diagonal and a negative value refers to a lower diagonal. Defaults to 
main diagonal (0).

Returns

* A light-weight object with the upper triangle of the matrix. Convertible to a 
matrix object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::triu(mat) << '\n';
    std::cout << np::triu(mat, -1) << '\n';
    std::cout << np::triu(mat, 1) << '\n';
    return 0;
}
```


Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1],
 [-3, 5, 0, -7]]
```

Output

```
[[ 1, -9,  0,  5],
 [ 0, -2,  7,  8],
 [ 0,  0,  3, -1],
 [ 0,  0,  0, -7]]
[[ 1, -9,  0,  5],
 [10, -2,  7,  8],
 [ 0, 12,  3, -1],
 [ 0,  0,  0, -7]]
[[ 0, -9,  0,  5],
 [ 0,  0,  7,  8],
 [ 0,  0,  0, -1],
 [ 0,  0,  0,  0]]
```

## Maximums and minimums

`argmax`

Return the index of the maximum value in the array.
```cpp
template <class T>
size_t argmax(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The index of the maximum value in the array.

Notes

* In case of multiple occurrences of the maximum value, return the index 
corresponding to the first occurrence.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::argmax(arr) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
7
```

`argmax`

Return the pair of indices of the maximum value in the matrix.
```cpp
template <class T>
void argmax(const matrix<T> &mat, size_t &i, size_t &j);
```

Parameters

* `mat` A matrix-like object.
* `i` Reference to an index where the row location will be stored.
* `j` Reference to an index where the column location will be stored.

Returns

* None

Notes

* In case of multiple occurrences of the maximum value, return the index 
corresponding to the first occurrence.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    size_t i, j;
    std::cin >> mat;
    np::argmax(mat, i, j);
    std::cout << "(" << i << ", " << j << ")\n";
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
(2, 1)
```

`argmax`

Return the index of the maximum value in the matrix along the specified axis. 
```cpp
template <class T>
array<size_t> argmax(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the index of the maximum value along each row. 
Otherwise, return the index of the maximum value along each column.

Returns

* A light-weight object with the index of the maximum value along an axis. 
Convertible to an array object.

Notes

* In case of multiple occurrences of the maximum value, return the index 
corresponding to the first occurrence.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::argmax(mat, true) << '\n';
    std::cout << "Column-wise: " << np::argmax(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [3, 0, 1]
Column-wise: [1, 2, 1, 1]
```

`argmin`

Return the index of the minimum value in the array.
```cpp
template <class T>
size_t argmin(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The index of the minimum value in the array.

Notes

* In case of multiple occurrences of the minimum value, return the index 
corresponding to the first occurrence.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::argmin(arr) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
1
```

`argmin`

Return the pair of indices of the minimum value in the matrix.
```cpp
template <class T>
void argmin(const matrix<T> &mat, size_t &i, size_t &j);
```

Parameters

* `mat` A matrix-like object.
* `i` Reference to an index where the row location will be stored.
* `j` Reference to an index where the column location will be stored.

Returns

* None

Notes

* In case of multiple occurrences of the minimum value, return the index 
corresponding to the first occurrence.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    size_t i, j;
    std::cin >> mat;
    np::argmin(mat, i, j);
    std::cout << "(" << i << ", " << j << ")\n";
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
(0, 1)
```

`argmin`

Return the index of the minimum value in the matrix along the specified axis. 
```cpp
template <class T>
array<size_t> argmin(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the index of the minimum value along each row. 
Otherwise, return the index of the minimum value along each column.

Returns

* A light-weight object with the index of the minimum value along an axis. 
Convertible to an array object.

Notes

* In case of multiple occurrences of the minimum value, return the index 
corresponding to the first occurrence.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::argmin(mat, true) << '\n';
    std::cout << "Column-wise: " << np::argmin(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [1, 1, 3]
Column-wise: [2, 0, 0, 2]
```

`amax`

Return the maximum value contained in the array. 
```cpp
template <class T>
T amax(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The maximum value in the array.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::amax(arr) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
12
```

`amax`

Return the maximum value contained in the matrix. 
```cpp
template <class T>
T amax(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* The maximum value in the matrix.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::amax(mat) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
12
```

`amax`

Return the maximum value contained in the matrix along the specified axis. 

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the maximum value along each row. Otherwise, 
return the maximum value along each column.

Returns

* A light-weight object with the maximum value along an axis. Convertible to an 
array object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::amax(mat, true) << '\n';
    std::cout << "Column-wise: " << np::amax(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [5, 10, 12]
Column-wise: [10, 12, 7, 8]
```

`amin`

Return the minimum value contained in the array.
```cpp
template <class T>
T amin(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The minimum value in the array.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::amin(arr) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
-9
```

`amin`

Return the minimum value contained in the matrix. 
```cpp
template <class T>
T amin(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* The minimum value in the matrix.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::amin(mat) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
-9
```

`amin`

Return the minimum value contained in the matrix along the specified axis. 
```cpp
template <class T>
array<T> amin(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the minimum value along each row. Otherwise, 
return the minimum value along each column.

Returns

* A light-weight object with the minimum value along an axis. Convertible to an 
array object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::amin(mat, true) << '\n';
    std::cout << "Column-wise: " << np::amin(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [-9, -2, -1]
Column-wise: [0, -9, 0, -1]
```

`maximum`

Return the element-wise maximum of two arrays.
```cpp
template <class T>
array<T> maximum(const array<T> &lhs, const array<T> &rhs);

template <class T>
array<T> maximum(const array<T> &lhs, const typename array<T>::value_type &val);

template <class T>
array<T> maximum(const typename array<T>::value_type &val, const array<T> &rhs);
```

Parameters

* `lhs` Left-hand side array-like object.
* `rhs` Right-hand side array-like object.
* `val` Value to use either as left-hand or right-hand operand.

Returns

* A light-weight object with the element-wise maximum of the two arrays. 
Convertible to an array object.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments 
are array objects with different sizes.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::maximum(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
[12, 5, 5, 10, 7, 7, 9, 17, -1, 3]
```

`maximum`

Return the element-wise maximum of two matrices.
```cpp
template <class T>
matrix<T> maximum(const matrix<T> &lhs, const matrix<T> &rhs);

template <class T>
matrix<T> maximum(const matrix<T> &lhs, const typename matrix<T>::value_type &val);

template <class T>
matrix<T> maximum(const typename matrix<T>::value_type &val, const matrix<T> &rhs);
```

Parameters

* `lhs` Left-hand side matrix-like object.
* `rhs` Right-hand side matrix-like object.
* `val` Value to use either as left-hand or right-hand operand.

Returns

* A light-weight object with the element-wise maximum of the two matrices. 
Convertible to a matrix object.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments 
are matrix objects with different number of rows and columns.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1, mat2;
    std::cin >> mat1 >> mat2;
    std::cout << np::maximum(mat1, mat2) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
[[10, -1,  5,  5],
 [10, 17, 11,  8],
 [ 8, 12,  3, -1]]
```

`minimum`

Return the element-wise minimum of two arrays.
```cpp
template <class T>
array<T> minimum(const array<T> &lhs, const array<T> &rhs);

template <class T>
array<T> minimum(const array<T> &lhs, const typename array<T>::value_type &val);

template <class T>
array<T> minimum(const typename array<T>::value_type &val, const array<T> &rhs);
```

Parameters

* `lhs` Left-hand side array-like object.
* `rhs` Right-hand side array-like object.
* `val` Value to use either as left-hand or right-hand operand.

Returns

* A light-weight object with the element-wise minimum of the two arrays. 
Convertible to an array object.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments 
are array objects with different sizes.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::minimum(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
[1, -9, -1, 3, -2, 2, 8, 12, -6, 0]
```

`minimum`

Return the element-wise minimum of two matrices.
```cpp
template <class T>
matrix<T> minimum(const matrix<T> &lhs, const matrix<T> &rhs);

template <class T>
matrix<T> minimum(const matrix<T> &lhs, const typename matrix<T>::value_type &val);

template <class T>
matrix<T> minimum(const typename matrix<T>::value_type &val, const matrix<T> &rhs);
```

Parameters

* `lhs` Left-hand side matrix-like object.
* `rhs` Right-hand side matrix-like object.
* `val` Value to use either as left-hand or right-hand operand.

Returns

* A light-weight object with the element-wise minimum of the two matrices. 
Convertible to a matrix object.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments 
are matrix objects with different number of rows and columns.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1, mat2;
    std::cin >> mat1 >> mat2;
    std::cout << np::minimum(mat1, mat2) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
[[  1,  -9,   0,   3],
 [  7,  -2,   7,   6],
 [  0,  -5,   1, -11]]
```

`clamp`

Clamp the values in the array. Given an interval [`a_min`, `a_max`], values 
smaller than `a_min` become `a_min`, and values larger than `a_max` become 
`a_max`.
```cpp
template <class T>
array<T> clamp(
    const array<T> &arr, 
    const typename array<T>::value_type & &a_min, 
    const typename array<T>::value_type & &a_max
);
```

Parameters

* `arr` An array-like object.
* `a_min` The lower boundary to clamp.
* `a_max` The upper boundary to clamp.

Returns

* A light-weight object with the array formed by clamping the values in the 
given array. Convertible to an array object.

Notes

* The behavior is undefined if `a_min` is greater than `a_max`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    int a_min, a_max;
    std::cin >> arr >> a_min >> a_max;
    std::cout << np::clamp(arr, a_min, a_max) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
1 10
```

Output

```
[1, 1, 5, 10, 1, 7, 8, 10, 1, 3]
```

`clamp`

Clamp the values in the matrix. Given an interval [`a_min`, `a_max`], values 
smaller than `a_min` become `a_min`, and values larger than `a_max` become 
`a_max`.
```cpp
template <class T>
matrix<T> clamp(
    const matrix<T> &mat, 
    const typename matrix<T>::value_type &a_min, 
    const typename matrix<T>::value_type &a_max
);
```

Parameters

* `mat` A matrix-like object.
* `a_min` The lower boundary to clamp.
* `a_max` The upper boundary to clamp.

Returns

* A light-weight object with the matrix formed by clamping the values in the 
given matrix. Convertible to a matrix object.

Notes

* The behavior is undefined if `a_min` is greater than `a_max`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    int a_min, a_max;
    std::cin >> mat >> a_min >> a_max;
    std::cout << np::clamp(mat, a_min, a_max) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
1 10
```

Output

```
[[ 1,  1,  1,  5],
 [10,  1,  7,  8],
 [ 1, 10,  3,  1]]
```

## Sums and products

`sum`

Return the sum of the array elements.
```cpp
template <class T>
T sum(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The sum of the array elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::sum(arr) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Output

```
55
```

`sum`

Return the sum of the matrix elements.
```cpp
template <class T>
T sum(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* The sum of the matrix elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::sum(mat) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
78
```

`sum`

Return the sum of the matrix elements along the specified axis.
```cpp
template <class T>
array<T> sum(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the sum of the elements along each row. 
Otherwise, return the sum of the elements along each column.

Returns

* A light-weight object with the sum along an axis. Convertible to an array 
object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::sum(mat, true) << '\n';
    std::cout << "Column-wise: " << np::sum(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
Row-wise: [10, 26, 42]
Column-wise: [15, 18, 21, 24]
```

`prod`

Return the product of the array elements.
```cpp
template <class T>
T prod(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The product of the array elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::prod(arr) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Output

```
3628800
```

`prod`

Return the product of the matrix elements.
```cpp
template <class T>
T prod(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* The product of the matrix elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::prod(mat) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
479001600
```

`prod`

Return the product of the matrix elements along the specified axis.
```cpp
template <class T>
array<T> prod(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the product of the elements along each row. 
Otherwise, return the product of the elements along each column.

Returns

* A light-weight object with the product along an axis. Convertible to an array 
object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::prod(mat, true) << '\n';
    std::cout << "Column-wise: " << np::prod(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
Row-wise: [24, 1680, 11880]
Column-wise: [45, 120, 231, 384]
```

`cumsum`

Return the cumulative sum of the array elements.
```cpp
template <class T>
array<T> cumsum(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The cumulative sum of the array elements.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::cumsum(arr) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Output

```
[1, 3, 6, 10, 15, 21, 28, 36, 45, 55]
```

`cumsum`

Return the cumulative sum of the matrix elements along the specified axis.
```cpp
template <class T>
matrix<T> cumsum(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the cumulative sum of the elements along each 
row. Otherwise, return the cumulative sum of the elements along each column.

Returns

* The cumulative sum along an axis.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise:\n" << np::cumsum(mat, true) << '\n';
    std::cout << "Column-wise:\n" << np::cumsum(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
Row-wise:
[[ 1,  3,  6, 10],
 [ 5, 11, 18, 26],
 [ 9, 19, 30, 42]]
Column-wise:
[[ 1,  2,  3,  4],
 [ 6,  8, 10, 12],
 [15, 18, 21, 24]]
```

`cumprod`

Return the cumulative product of the array elements.
```cpp
template <class T>
array<T> cumprod(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The cumulative product of the array elements.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::cumprod(arr) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Output

```
[1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]
```

`cumprod`

Return the cumulative product of the matrix elements along the specified axis.
```cpp
template <class T>
matrix<T> cumprod(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the cumulative product of the elements along each 
row. Otherwise, return the cumulative product of the elements along each 
column.

Returns

* The cumulative product along an axis.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise:\n" << np::cumprod(mat, true) << '\n';
    std::cout << "Column-wise:\n" << np::cumprod(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
Row-wise:
[[    1,     2,     6,    24],
 [    5,    30,   210,  1680],
 [    9,    90,   990, 11880]]
Column-wise:
[[  1,   2,   3,   4],
 [  5,  12,  21,  32],
 [ 45, 120, 231, 384]]
```

## Concatenation

`concatenate`

Concatenate one or more arrays.
```cpp
template <class T, class... Arrays>
array<T> concatenate(const array<T> &arr1, const Arrays&... arr2);
```

Parameters

* `arr1, arr2...` Arrays to concatenate. All arrays must have same data type.

Returns

* The array formed by concatenating the array arguments.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::concatenate(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7]
[8, 9, 10]
```

Output

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

`row_stack`

Concatenate one or more arrays and matrices vertically.
```cpp
template <class T, class... Matrices>
matrix<T> row_stack(const matrix<T> &mat1, const Matrices&... mat2);

template <class T, class... Matrices>
matrix<T> row_stack(const array<T> &arr1, const Matrices&... mat2);
```

Parameters

* `mat1, mat2...` Matrices to stack. All matrices must have same data type. 
Arrays are treated as row vectors.

Returns

* The matrix formed by stacking the array and matrix arguments row-wise.

Exceptions

* `std::invalid_argument` Thrown if the number of columns is not the same for 
all the arguments.
* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1, mat2;
    np::array<int> arr;
    std::cin >> mat1 >> mat2 >> arr;
    std::cout << np::row_stack(mat1, mat2, arr) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8]]
[[9, 10, 11, 12],
 [13, 14, 15, 16],
 [17, 18, 19, 20]]
[21, 22, 23, 24]
```

Output

```
[[ 1,  2,  3,  4],
 [ 5,  6,  7,  8],
 [ 9, 10, 11, 12],
 [13, 14, 15, 16],
 [17, 18, 19, 20],
 [21, 22, 23, 24]]
```

`column_stack`

Concatenate one or more arrays and matrices horizontally.
```cpp
template <class T, class... Matrices>
matrix<T> column_stack(const matrix<T> &mat1, const Matrices&... mat2);

template <class T, class... Matrices>
matrix<T> column_stack(const array<T> &arr1, const Matrices&... mat2);
```

Parameters

* `mat1, mat2...` Matrices to stack. All matrices must have same data type. 
Arrays are treated as column vectors.

Returns

* The matrix formed by stacking the array and matrix arguments column-wise.

Exceptions

* `std::invalid_argument` Thrown if the number of rows is not the same for all 
the arguments.
* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1, mat2;
    np::array<int> arr;
    std::cin >> mat1 >> mat2 >> arr;
    std::cout << np::column_stack(mat1, mat2, arr) << '\n';
    return 0;
}
```

Input

```
[[1, 5],
 [2, 6],
 [3, 7],
 [4, 8]]
[[9, 13, 17],
 [10, 14, 18],
 [11, 15, 19],
 [12, 16, 20]]
[21, 22, 23, 24]
```

Output

```
[[ 1,  5,  9, 13, 17, 21],
 [ 2,  6, 10, 14, 18, 22],
 [ 3,  7, 11, 15, 19, 23],
 [ 4,  8, 12, 16, 20, 24]]
```

## Padding

`pad`

Pad an array.
```cpp
template <class T>
array<T> pad(
    const array<T> &arr, size_t before, size_t after, 
    const std::string &mode = "empty", 
    std::initializer_list<typename array<T>::value_type> args = {}
);
```

Parameters

* `arr` The array to pad.
* `before` Number of elements to pad at the beginning of the array.
* `after` Number of elements to pad at the end of the array.
* `mode` One of the following string values:
  - `"empty"` (default) Pads with uninitialized values.
  - `"constant"` Pads with a constant value.
  - `"edge"` Pads with the edge values of the array.
  - `"linear_ramp"` Pads with the linear ramp between the array edge value and 
    an end value.
  - `"reflect"` Pads with the reflection of the array mirrored on the first and 
    last values.
  - `"symmetric"` Pads with the reflection of the array mirrored along the 
    edge.
  - `"wrap"` Pads with the wrap of the array.
* `args` An initializer list with additional arguments to be used in 
`"constant"` and `"linear_ramp"` modes. If empty, a 0 will be used as before 
and after constants. If a single value is passed, it will be used as both 
before and after constants. If two values are passed, they will be used as 
before and after constants.

Returns

* The padded array.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    int before, after;
    double val;
    std::cin >> arr >> before >> after >> val;
    std::cout << "Empty padding:\n" 
              << np::pad(arr, before, after) << '\n';
    std::cout << "Constant padding:\n" 
              << np::pad(arr, before, after, "constant", {val}) << '\n';
    std::cout << "Edge padding:\n" 
              << np::pad(arr, before, after, "edge") << '\n';
    std::cout << "Linear ramp padding:\n" 
              << np::pad(arr, before, after, "linear_ramp", {val}) << '\n';
    std::cout << "Reflect padding:\n" 
              << np::pad(arr, before, after, "reflect") << '\n';
    std::cout << "Symmetric padding:\n" 
              << np::pad(arr, before, after, "symmetric") << '\n';
    std::cout << "Wrap padding:\n" 
              << np::pad(arr, before, after, "wrap") << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5]
3 4
0
```

Output

```
Empty padding:
[1.4755599e-311, 1.4755598e-311, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0]
Constant padding:
[0, 0, 0, 1, 2, 3, 4, 5, 0, 0, 0, 0]
Edge padding:
[1, 1, 1, 1, 2, 3, 4, 5, 5, 5, 5, 5]
Linear ramp padding:
[0, 0.33333333, 0.66666667, 1, 2, 3, 4, 5, 3.75, 2.5, 1.25, 0]
Reflect padding:
[4, 3, 2, 1, 2, 3, 4, 5, 4, 3, 2, 1]
Symmetric padding:
[3, 2, 1, 1, 2, 3, 4, 5, 5, 4, 3, 2]
Wrap padding:
[3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4]
```

`pad`

Pad a matrix.
```cpp
template <class T>
matrix<T> pad(
    const matrix<T> &mat, 
    size_t before1, size_t after1, size_t before2, size_t after2, 
    const std::string &mode = "empty", 
    std::initializer_list<typename matrix<T>::value_type> args = {}
);
```

Parameters

* `mat` The matrix to pad.
* `before1` Number of elements to pad at the top of the matrix.
* `after1` Number of elements to pad at the bottom of the matrix.
* `before2` Number of elements to pad at the left of the matrix.
* `after2` Number of elements to pad at the right of the matrix.
* `mode` One of the following string values:
  - `"empty"` (default) Pads with uninitialized values.
  - `"constant"` Pads with a constant value.
  - `"edge"` Pads with the edge values along each axis.
  - `"linear_ramp"` Pads with the linear ramp between the edge value and an end 
    value.
  - `"reflect"` Pads with the reflection mirrored on the first and last values 
    along each axis.
  - `"symmetric"` Pads with the reflection mirrored along the edge on each axis.
  - `"wrap"` Pads with the wrap of the matrix.
* `args` An initializer list with additional arguments to be used in 
`"constant"` and `"linear_ramp"` modes. If empty, a 0 will be used for all the 
constants. If a single value is passed, the same value will be used for all the 
constants. If two values are passed, the first one will be used as before1 and 
after1 constants and the later oner as before2 and after2 constants. If four 
values are passed, they will be used as before1, after1, before2 and after2 
constants.

Returns

* The padded matrix.

Notes

* The matrix is padded first column-wise and then row-wise.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    int before1, after1, before2, after2;
    double val;
    std::cin >> mat >> before1 >> after1 >> before2 >> after2 >> val;
    np::printoptions::precision = 3;
    std::cout << "Empty padding:\n" 
              << np::pad(mat, before1, after1, before2, after2) << '\n';
    std::cout << "Constant padding:\n" 
              << np::pad(mat, before1, after1, before2, after2, "constant", {val}) 
              << '\n';
    std::cout << "Edge padding:\n" 
              << np::pad(mat, before1, after1, before2, after2, "edge") << '\n';
    std::cout << "Linear ramp padding:\n" 
              << np::pad(mat, before1, after1, before2, after2, "linear_ramp", {val}) 
              << '\n';
    std::cout << "Reflect padding:\n" 
              << np::pad(mat, before1, after1, before2, after2, "reflect") << '\n';
    std::cout << "Symmetric padding:\n" 
              << np::pad(mat, before1, after1, before2, after2, "symmetric") << '\n';
    std::cout << "Wrap padding:\n" 
              << np::pad(mat, before1, after1, before2, after2, "wrap") << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12],
 [13, 14, 15, 16]]
2 3 3 2
0
```

Output

```
Empty padding:
[[1.46e-311, 1.46e-311,         0,         0,         0,         0,         0,         0,         0],
 [        0,         0,         0,         0, 6.95e-310,         0,         0,         0, 6.95e-310],
 [        0,         0,         0,         1,         2,         3,         4, 6.95e-310,         0],
 [        0,         0, 6.95e-310,         5,         6,         7,         8,         0,         0],
 [        0, 6.95e-310,         0,         9,        10,        11,        12, 6.95e-310,         0],
 [1.09e-309, 1.46e-311, 1.46e-311,        13,        14,        15,        16, 9.45e+170, 1.46e-306],
 [ 3.84e+06, 2.85e+101,  7.72e+44,  1.36e+69,  6.84e+25,  9.35e+25,  8.8e+175,  2.12e+88,  1.51e-13],
 [1.29e+248, 1.65e+265,  4.86e-28,  3.04e+93,  3.97e+06,  3.18e+64,  2.12e+88,  4.79e+06, 2.65e+180],
 [ 3.26e+88,  1.08e+26,  3.47e-86,  9.33e+68,  3.31e-33,  5.71e+14,  3.01e+64, 2.11e+214,  1.15e+21]]
Constant padding:
[[ 0,  0,  0,  0,  0,  0,  0,  0,  0],
 [ 0,  0,  0,  0,  0,  0,  0,  0,  0],
 [ 0,  0,  0,  1,  2,  3,  4,  0,  0],
 [ 0,  0,  0,  5,  6,  7,  8,  0,  0],
 [ 0,  0,  0,  9, 10, 11, 12,  0,  0],
 [ 0,  0,  0, 13, 14, 15, 16,  0,  0],
 [ 0,  0,  0,  0,  0,  0,  0,  0,  0],
 [ 0,  0,  0,  0,  0,  0,  0,  0,  0],
 [ 0,  0,  0,  0,  0,  0,  0,  0,  0]]
Edge padding:
[[ 1,  1,  1,  1,  2,  3,  4,  4,  4],
 [ 1,  1,  1,  1,  2,  3,  4,  4,  4],
 [ 1,  1,  1,  1,  2,  3,  4,  4,  4],
 [ 5,  5,  5,  5,  6,  7,  8,  8,  8],
 [ 9,  9,  9,  9, 10, 11, 12, 12, 12],
 [13, 13, 13, 13, 14, 15, 16, 16, 16],
 [13, 13, 13, 13, 14, 15, 16, 16, 16],
 [13, 13, 13, 13, 14, 15, 16, 16, 16],
 [13, 13, 13, 13, 14, 15, 16, 16, 16]]
Linear ramp padding:
[[    0,     0,     0,     0,     0,     0,     0,     0,     0],
 [    0, 0.167, 0.333,   0.5,     1,   1.5,     2,     1,     0],
 [    0, 0.333, 0.667,     1,     2,     3,     4,     2,     0],
 [    0,  1.67,  3.33,     5,     6,     7,     8,     4,     0],
 [    0,     3,     6,     9,    10,    11,    12,     6,     0],
 [    0,  4.33,  8.67,    13,    14,    15,    16,     8,     0],
 [    0,  2.89,  5.78,  8.67,  9.33,    10,  10.7,  5.33,     0],
 [    0,  1.44,  2.89,  4.33,  4.67,     5,  5.33,  2.67,     0],
 [    0,     0,     0,     0,     0,     0,     0,     0,     0]]
Reflect padding:
[[12, 11, 10,  9, 10, 11, 12, 11, 10],
 [ 8,  7,  6,  5,  6,  7,  8,  7,  6],
 [ 4,  3,  2,  1,  2,  3,  4,  3,  2],
 [ 8,  7,  6,  5,  6,  7,  8,  7,  6],
 [12, 11, 10,  9, 10, 11, 12, 11, 10],
 [16, 15, 14, 13, 14, 15, 16, 15, 14],
 [12, 11, 10,  9, 10, 11, 12, 11, 10],
 [ 8,  7,  6,  5,  6,  7,  8,  7,  6],
 [ 4,  3,  2,  1,  2,  3,  4,  3,  2]]
Symmetric padding:
[[ 7,  6,  5,  5,  6,  7,  8,  8,  7],
 [ 3,  2,  1,  1,  2,  3,  4,  4,  3],
 [ 3,  2,  1,  1,  2,  3,  4,  4,  3],
 [ 7,  6,  5,  5,  6,  7,  8,  8,  7],
 [11, 10,  9,  9, 10, 11, 12, 12, 11],
 [15, 14, 13, 13, 14, 15, 16, 16, 15],
 [15, 14, 13, 13, 14, 15, 16, 16, 15],
 [11, 10,  9,  9, 10, 11, 12, 12, 11],
 [ 7,  6,  5,  5,  6,  7,  8,  8,  7]]
Wrap padding:
[[10, 11, 12,  9, 10, 11, 12,  9, 10],
 [14, 15, 16, 13, 14, 15, 16, 13, 14],
 [ 2,  3,  4,  1,  2,  3,  4,  1,  2],
 [ 6,  7,  8,  5,  6,  7,  8,  5,  6],
 [10, 11, 12,  9, 10, 11, 12,  9, 10],
 [14, 15, 16, 13, 14, 15, 16, 13, 14],
 [ 2,  3,  4,  1,  2,  3,  4,  1,  2],
 [ 6,  7,  8,  5,  6,  7,  8,  5,  6],
 [10, 11, 12,  9, 10, 11, 12,  9, 10]]
```

## Insertion-deletion

`insert`

Insert values before the given indices.
```cpp
template <class T>
array<T> insert(
    const array<T> &arr, size_t index, const typename array<T>::value_type &value
);

template <class T>
array<T> insert(
    const array<T> &arr, const array<size_t> &index, const array<T> &value
);
```

Parameters

* `arr` An array-like object.
* `index` A single position or an array of positions in the array where the 
values are inserted.
* `value` A single value or an array of values to be inserted into the array.

Returns

* A new array with the values inserted. Note that insert does not occur 
in-place, a new array is returned.

Exceptions

* `std::invalid_argument` Thrown if `index` and `value` arguments are array 
objects with different sizes.
* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr, value;
    np::array<size_t> index;
    std::cin >> arr >> index >> value;
    std::cout << np::insert(arr, index, value) << '\n';
    return 0;
}
```

Input

```
[1, 5, 10, -2, 8, 0]
[5, 1, 6, 4]
[12, -9, 3, 7]
```

Output

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

`erase`

Removes elements from the array.
```cpp
template <class T>
array<T> erase(const array<T> &arr, size_t index);

template <class T>
array<T> erase(const array<T> &arr, const array<size_t> &index);
```

Parameters

* `arr` An array-like object.
* `index` A single position or an array of positions in the array of the 
elements to be removed.

Returns

* A new array with the elements removed. Note that erase does not occur 
in-place, a new array is returned.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    np::array<size_t> index;
    std::cin >> arr >> index;
    std::cout << np::erase(arr, index) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
[9, 1, 5, 7]
```

Output

```
[1, 5, 10, -2, 8, 0]
```

## Logic functions

`all`

Test whether all the elements in the array evaluate to `true`.
```cpp
bool all(const array<bool> &arr);
```

Parameters

* `arr` An array-like of `bool`.

Returns

* `true` if all the elements evaluate to `true` and `false` otherwise.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << std::boolalpha << np::all(arr >= 0) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
false
```

`all`

Test whether all the elements in the matrix evaluate to `true`.
```cpp
bool all(const matrix<bool> &mat);
```

Parameters

* `mat` A matrix-like of `bool`.

Returns

* `true` if all the elements evaluate to `true` and `false` otherwise.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << std::boolalpha << np::all(mat >= 0) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
false
```

`all`

Test whether all the elements along the specified axis evaluate to `true`.
```cpp
array<bool> all(const matrix<bool> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like of `bool`.
* `rowwise` If `true`, test along the elements on each row. Otherwise, test 
along the elements on each column.

Returns

* A light-weight object with the results of the test along an axis. Convertible 
to an array of `bool`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << std::boolalpha;
    std::cout << "Row-wise: " << np::all(mat >= 0, true) << '\n';
    std::cout << "Column-wise: " << np::all(mat >= 0, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [false, false, false]
Column-wise: [true, false, true, false]
```

`any`

Test whether any element in the array evaluate to `true`.
```cpp
bool any(const array<bool> &arr);
```

Parameters

* arr An array-like of `bool`.

Returns

* `true` if any element evaluate to `true` and `false` otherwise.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << std::boolalpha << np::any(arr < 0) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
true
```

`any`

Test whether any element in the matrix evaluate to `true`.
```cpp
bool any(const matrix<bool> &mat);
```

Parameters

* `mat` A matrix-like of `bool`.

Returns

* `true` if any element evaluate to `true` and `false` otherwise.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << std::boolalpha << np::any(mat < 0) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
true
```

`any`

Test whether any element along the specified axis evaluate to `true`.
```cpp
array<bool> any(const matrix<bool> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like of `bool`.
* `rowwise` If `true`, test along the elements on each row. Otherwise, test 
along the elements on each column.

Returns

* A light-weight object with the results of the test along an axis. Convertible 
to an array of `bool`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << std::boolalpha;
    std::cout << "Row-wise: " << np::any(mat < 0, true) << '\n';
    std::cout << "Column-wise: " << np::any(mat < 0, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [true, true, true]
Column-wise: [false, true, false, true]
```

`count_nonzero`

Count the number of non-zero elements in the array.
```cpp
template <class T>
size_t count_nonzero(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The number of non-zero elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::count_nonzero(arr >= 0) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
8
```

`count_nonzero`

Count the number of non-zero elements in the matrix.
```cpp
template <class T>
size_t count_nonzero(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* The number of non-zero elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::count_nonzero(mat >= 0) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
9
```

`count_nonzero`

Count the number of non-zero elements along the specified axis.
```cpp
template <class T>
array<size_t> count_nonzero(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, count the number of non-zero elements along each row. 
Otherwise, count the number of non-zero elements along each column.

Returns

* A light-weight object with the number of non-zero elements along an axis. 
Convertible to an array object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::count_nonzero(mat >= 0, true) << '\n';
    std::cout << "Column-wise: " << np::count_nonzero(mat >= 0, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [3, 3, 3]
Column-wise: [3, 1, 3, 2]
```

`isclose`

Return if two numbers are equal within a tolerance.
```cpp
bool isclose(double a, double b, double rtol = 1e-8, double atol = 0);

bool isclose(float a, float b, float rtol = 1e-8f, float atol = 0);

bool isclose(
    long double a, long double b, long double rtol = 1e-8L, long double atol = 0
);
```

Whether or not two values are considered equal is determined according to given 
absolute and relative tolerance. The tolerances must be non-negative, typically 
very small numbers. For floating-point values, the function uses the following 
equation to test whether two numbers are equivalent:

```
abs(a - b) <= max(rtol*max(abs(a), abs(b)), atol)
```

NaN is not considered equal to any other value, including NaN. inf and -inf are 
only considered equal to themselves.

Parameters

* `a` A floating-point number.
* `b` A floating-point number.
* `rtol` The relative tolerance.
* `atol` The absolute tolerance.

Returns

* `true` if the values are considered equal and `false` otherwise.

`isclose`

Return if two arrays are equal, element-wise, within a tolerance.
```cpp
template <class T>
array<bool> isclose(
    const array<T> &lhs, const array<T> &rhs,
    const T &rtol = T(1e-8), const T &atol = T(0)
);

template <class T>
array<bool> isclose(
    const array<T> &lhs, const typename array<T>::value_type &val,
    const T &rtol = T(1e-8), const T &atol = T(0)
);

template <class T>
array<bool> isclose(
    const typename array<T>::value_type &val, const array<T> &rhs,
    const T &rtol = T(1e-8), const T &atol = T(0)
);
```

Parameters

* `lhs` Left-hand side array-like object.
* `rhs` Right-hand side array-like object.
* `val` Value to use either as left-hand or right-hand operand.
* `rtol` The relative tolerance.
* `atol` The absolute tolerance.

Returns

* A light-weight object with the results of the test. Convertible to an array 
of `bool`.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments 
are array objects with different sizes.

`isclose`

Return if two matrices are equal, element-wise, within a tolerance.
```cpp
template <class T>
matrix<bool> isclose(
    const matrix<T> &lhs, const matrix<T> &rhs,
    const T &rtol = T(1e-8), const T &atol = T(0)
);

template <class T>
matrix<bool> isclose(
    const matrix<T> &lhs, const typename matrix<T>::value_type &val,
    const T &rtol = T(1e-8), const T &atol = T(0)
);

template <class T>
matrix<bool> isclose(
    const typename matrix<T>::value_type &val, const matrix<T> &rhs,
    const T &rtol = T(1e-8), const T &atol = T(0)
);
```

Parameters

* `lhs` Left-hand side matrix-like object.
* `rhs` Right-hand side matrix-like object.
* `val` Value to use either as left-hand or right-hand operand.
* `rtol` The relative tolerance.
* `atol` The absolute tolerance.

Returns

* A light-weight object with the results of the test. Convertible to a matrix 
of `bool`.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments 
are matrix objects with different number of rows and columns.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double inf = np::constants<double>::inf;
    double nan = np::constants<double>::nan;
    np::array<double> arr1{       1.0, 1.0 + 1e-8, 0.33333333,     1e7,
                                  1e8,    1.0/0.0,   -1.0/0.0, 0.0/0.0};
    np::array<double> arr2{1.0 + 1e-7,        1.0,    1.0/3.0, 1e7 + 1, 
                              1e8 + 1,        inf,        inf,     nan};
    std::cout << arr1 << '\n';
    std::cout << arr2 << '\n';
    std::cout << std::boolalpha;
    std::cout << "Using isclose: " << np::isclose(arr1, arr2) << '\n';
    std::cout << "Using == operator: " << (arr1 == arr2) << '\n';
    return 0;
}
```

Output

```
[1, 1, 0.33333333, 10000000, 1e+08, inf, -inf, nan]
[1.0000001, 1, 0.33333333, 10000001, 1e+08, inf, inf, nan]
Using isclose: [false, true, true, false, true, true, false, false]
Using == operator: [false, false, false, false, false, true, false, false]
```

`allclose`

Test whether all the elements in two arrays are element-wise equal within a 
tolerance.
```cpp
template <class T>
bool allclose(
    const array<T> &lhs, const array<T> &rhs,
    const T &rtol = T(1e-8), const T &atol = T(0)
);

template <class T>
bool allclose(
    const array<T> &lhs, const typename array<T>::value_type &val,
    const T &rtol = T(1e-8), const T &atol = T(0)
);

template <class T>
bool allclose(
    const typename array<T>::value_type &val, const array<T> &rhs,
    const T &rtol = T(1e-8), const T &atol = T(0)
);
```

Parameters

* `lhs` Left-hand side array-like object.
* `rhs` Right-hand side array-like object.
* `val` Value to use either as left-hand or right-hand operand.
* `rtol` The relative tolerance.
* `atol` The absolute tolerance.

Returns

* `true` if all the elements are considered equal and `false` otherwise.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments 
are array objects with different sizes.

`allclose`

Test whether all the elements in two matrices are element-wise equal within a 
tolerance.
```cpp
template <class T>
bool allclose(
    const matrix<T> &lhs, const matrix<T> &rhs,
    const T &rtol = T(1e-8), const T &atol = T(0)
);

template <class T>
bool allclose(
    const matrix<T> &lhs, const typename matrix<T>::value_type &val,
    const T &rtol = T(1e-8), const T &atol = T(0)
);

template <class T>
bool allclose(
    const typename matrix<T>::value_type &val, const matrix<T> &rhs,
    const T &rtol = T(1e-8), const T &atol = T(0)
);
```

Parameters

* `lhs` Left-hand side matrix-like object.
* `rhs` Right-hand side matrix-like object.
* `val` Value to use either as left-hand or right-hand operand.
* `rtol` The relative tolerance.
* `atol` The absolute tolerance.

Returns

* `true` if all the elements are considered equal and `false` otherwise.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments 
are matrix objects with different number of rows and columns.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double inf = np::constants<double>::inf;
    np::array<double> arr1{1.0 + 1e-8, 0.33333333,     1e8, 1.0/0.0, -1.0/0.0};
    np::array<double> arr2{       1.0,    1.0/3.0, 1e8 + 1,     inf,     -inf};
    std::cout << arr1 << '\n';
    std::cout << arr2 << '\n';
    std::cout << std::boolalpha;
    std::cout << "Using allclose: " << np::allclose(arr1, arr2) << '\n';
    std::cout << "Using == operator: " << np::all(arr1 == arr2) << '\n';
    return 0;
}
```

Output

```
[1, 0.33333333, 1e+08, inf, -inf]
[1, 0.33333333, 1e+08, inf, -inf]
Using allclose: true
Using == operator: false
```

## Sorting and searching

`argsort`

Return the indices that would sort the array.
```cpp
template <class T>
array<size_t> argsort(const array<T> &arr);

template <class T, class Compare>
array<size_t> argsort(const array<T> &arr, Compare comp, bool stable = false);
```

Parameters

* `arr` An array-like object.
* `comp` Custom comparator. A binary function that accepts two elements of type 
`T` as arguments, and returns a value convertible to `bool`. The value returned 
indicates whether the element passed as first argument is considered to go 
before the second.
* `stable` If `true`, preserve the relative order of the elements with 
equivalent values. Otherwise, equivalent elements are not guaranteed to keep 
their original relative order.

Returns

* An array of indices that sort the array.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;

bool sort_by_abs(int a, int b) {
    return std::abs(a) < std::abs(b);
}

int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << "Default sort:\n";
    std::cout << np::argsort(arr) << '\n';
    std::cout << "Sort by absolute value:\n";
    std::cout << np::argsort(arr, sort_by_abs, true) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
Default sort:
[1, 4, 8, 0, 9, 2, 5, 6, 3, 7]
Sort by absolute value:
[0, 8, 4, 9, 2, 5, 1, 6, 3, 7]
```

`sort`

Return a sorted copy of the array.
```cpp
template <class T>
array<T> sort(const array<T> &arr);

template <class T, class Compare>
array<T> sort(const array<T> &arr, Compare comp, bool stable = false);
```

Parameters

* `arr` An array-like object.
* `comp` Custom comparator. A binary function that accepts two elements of type 
`T` as arguments, and returns a value convertible to `bool`. The value returned 
indicates whether the element passed as first argument is considered to go 
before the second.
* `stable` If `true`, preserve the relative order of the elements with 
equivalent values. Otherwise, equivalent elements are not guaranteed to keep 
their original relative order.

Returns

* A sorted copy of the array.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;

bool sort_by_abs(int a, int b) {
    return std::abs(a) < std::abs(b);
}

int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << "Default sort:\n";
    std::cout << np::sort(arr) << '\n';
    std::cout << "Sort by absolute value:\n";
    std::cout << np::sort(arr, sort_by_abs, true) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
Default sort:
[-9, -2, -1, 1, 3, 5, 7, 9, 10, 12]
Sort by absolute value:
[1, -1, -2, 3, 5, 7, -9, 9, 10, 12]
```

`argpartition`

Return the indices that would partition the array.
```cpp
template <class T>
array<size_t> argpartition(const array<T> &arr, size_t kth);

template <class T, class Compare>
array<size_t> argpartition(const array<T> &arr, size_t kth, Compare comp);
```

Parameters

* `arr` An array-like object.
* `kth` Element index to partition by. The element at the `kth` position is the 
element that would be in that position in the sorted array. The other elements 
are left without any specific order, except that none of the elements preceding 
`kth` are greater than it, and none of the elements following it are less.
* `comp` Custom comparator. A binary function that accepts two elements of type 
`T` as arguments, and returns a value convertible to `bool`. The value returned 
indicates whether the element passed as first argument is considered to go 
before the second.

Returns

* An array of indices that partitions the array.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;

bool sort_by_abs(int a, int b) {
    return std::abs(a) < std::abs(b);
}

int main() {
    np::array<int> arr;
    int kth;
    std::cin >> arr >> kth;
    std::cout << "Default partition:\n";
    std::cout << np::argpartition(arr, kth) << '\n';
    std::cout << "Partition by absolute value:\n";
    std::cout << np::argpartition(arr, kth, sort_by_abs) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
4
```

Output

```
Default partition:
[4, 1, 8, 0, 9, 5, 6, 7, 3, 2]
Partition by absolute value:
[8, 0, 9, 4, 2, 5, 6, 7, 3, 1]
```

`partition`

Return a partitioned copy of the array.
```cpp
template <class T>
array<T> partition(const array<T> &arr, size_t kth);

template <class T, class Compare>
array<T> partition(const array<T> &arr, size_t kth, Compare comp);
```

Parameters

* `arr` An array-like object.
* `kth` Element index to partition by. The element at the `kth` position is the 
element that would be in that position in the sorted array. The other elements 
are left without any specific order, except that none of the elements preceding 
`kth` are greater than it, and none of the elements following it are less.
* `comp` Custom comparator. A binary function that accepts two elements of type 
`T` as arguments, and returns a value convertible to `bool`. The value returned 
indicates whether the element passed as first argument is considered to go 
before the second.

Returns

* A partitioned copy of the array.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;

bool sort_by_abs(int a, int b) {
    return std::abs(a) < std::abs(b);
}

int main() {
    np::array<int> arr;
    int kth;
    std::cin >> arr >> kth;
    std::cout << "Default partition:\n";
    std::cout << np::partition(arr, kth) << '\n';
    std::cout << "Partition by absolute value:\n";
    std::cout << np::partition(arr, kth, sort_by_abs) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
4
```

Output

```
Default partition:
[-2, -9, -1, 1, 3, 7, 9, 12, 10, 5]
Partition by absolute value:
[-1, 1, 3, -2, 5, 7, 9, 12, 10, -9]
```

`where`

Find the indices of the elements that evaluate to `true`.
```cpp
array<size_t> where(const array<bool> &condition);
```

Parameters

* `condition` An array-like of `bool`.

Returns

* An array of indices of the elements equal to `true`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::where(arr >= 0) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
[0, 2, 3, 5, 6, 7, 8, 9]
```

`where`

Find the pairs of indices of the elements that evaluate to `true`.
```cpp
array< std::pair<size_t, size_t> > where(const base_matrix<bool> &condition);
```

Parameters

* `condition` A matrix-like of `bool`.

Returns

* An array of pairs of indices of the elements equal to `true`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;

namespace std {
    // Overload output of pairs.
    template <class T, class U>
    ostream& operator<<(ostream &ostr, const pair<T, U> &rhs) {
        return ostr << '(' << rhs.first << ", " << rhs.second << ')';
    }
}

int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::where(mat >= 0) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
[(0, 0), (0, 2), (0, 3), (1, 0), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2)]
```

## Basic statistics

`mean`

Return the average of the array elements.
```cpp
template <class T>
T mean(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* The average of the array elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << np::mean(arr) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
3.5
```

`mean`

Return the average of the matrix elements.
```cpp
template <class T>
T mean(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* The average of the matrix elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << np::mean(mat) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
2.83333
```

`mean`

Return the average of the matrix elements along the specified axis.
```cpp
template <class T>
array<T> mean(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the average of the elements along each row. 
Otherwise, return the average of the elements along each column.

Returns

* A light-weight object with the average along an axis. Convertible to an 
array object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::mean(mat, true) << '\n';
    std::cout << "Column-wise: " << np::mean(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [-0.75, 5.75, 3.5]
Column-wise: [3.6666667, 0.33333333, 3.3333333, 4]
```

`median`

Return the median of the array elements.
```cpp
template <class T>
T median(const array<T> &arr);
```

The median is defined as the middle value of a sorted copy of the array. If the 
length is even, the average of the two middle values is returned.

Parameters

* `arr` An array-like object.

Returns

* The median of the array elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << np::median(arr) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
4
```

`median`

Return the median of the matrix elements.
```cpp
template <class T>
T median(const matrix<T> &mat);
```

Parameters

* `mat` A matrix-like object.

Returns

* The median of the matrix elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << np::median(mat) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
2
```

`median`

Return the median of the matrix elements along the specified axis.
```cpp
template <class T>
array<T> median(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, return the median of the elements along each row. 
Otherwise, return the median of the elements along each column.

Returns

* A light-weight object with the median along an axis. Convertible to an array 
object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::median(mat, true) << '\n';
    std::cout << "Column-wise: " << np::median(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [0.5, 7.5, 1.5]
Column-wise: [1, -2, 3, 5]
```

`var`

Return the variance of the array elements. 
```cpp
template <class T>
T var(const array<T> &arr, size_t ddof = 0);
```

The variance is defined as the average of the squared deviations from the mean. 
```
var(a) = mean(abs(a - mean(a))**2)
```
The mean is calculated as `sum(*)/n`, where `n = a.size()`. However, if `ddof` 
is specified, the divisor `n - ddof` is used instead of `n`. 

In statistics, `ddof = 1` provides an unbiased estimator of the sample 
variance; while `ddof = 0` provides the maximum likelihood estimator of the 
variance for normally distributed variables.

Parameters

* `arr` An array-like object.
* `ddof` Delta degrees of freedom.

Returns

* The variance of the array elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << "Biased: " << np::var(arr) << '\n';
    std::cout << "Unbiased: " << np::var(arr, 1) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
Biased: 35.45
Unbiased: 39.3889
```

`var`

Return the variance of the matrix elements.
```cpp
template <class T>
T var(const matrix<T> &mat, size_t ddof = 0);
``` 

Parameters

* `mat` A matrix-like object.
* `ddof` Delta degrees of freedom.

Returns

* The variance of the matrix elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Biased: " << np::var(mat) << '\n';
    std::cout << "Unbiased: " << np::var(mat, 1) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Biased: 31.8056
Unbiased: 34.697
```

`var`

Return the variance of the matrix elements along the specified axis.
```cpp
template <class T>
array<T> var(const matrix<T> &mat, size_t ddof, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `ddof` Delta degrees of freedom.
* `rowwise` If `true`, return the variance of the elements along each row. 
Otherwise, return the variance of the elements along each column.

Returns

* A light-weight object with the variance along an axis. Convertible to an 
array object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Row-wise (biased): " << np::var(mat, 0, true) << '\n';
    std::cout << "Row-wise (unbiased): " << np::var(mat, 1, true) << '\n';
    std::cout << "Column-wise (biased): " << np::var(mat, 0, false) << '\n';
    std::cout << "Column-wise (unbiased): " << np::var(mat, 1, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise (biased): [26.1875, 21.1875, 26.25]
Row-wise (unbiased): [34.916667, 28.25, 35]
Column-wise (biased): [20.222222, 76.222222, 8.2222222, 14]
Column-wise (unbiased): [30.333333, 114.33333, 12.333333, 21]
```

`stddev`

Return the standard deviation of the array elements.
```cpp
template <class T>
T stddev(const array<T> &arr, size_t ddof = 0);
```

The standard deviation is defined as the square root of the variance. 
```
stddev(a) = sqrt(var(a))
```

Parameters

* `arr` An array-like object.
* `ddof` Delta degrees of freedom.

Returns

* The standard deviation of the array elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << np::stddev(arr) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
5.95399
```

`stddev`

Return the standard deviation of the matrix elements. 
```cpp
template <class T>
T stddev(const matrix<T> &mat, size_t ddof = 0);
```

Parameters

* `mat` A matrix-like object.
* `ddof` Delta degrees of freedom.

Returns

* The standard deviation of the matrix elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << np::stddev(mat) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
5.63964
```

`stddev`

Return the standard deviation of the matrix elements along the specified axis.
```cpp
template <class T>
array<T> stddev(const matrix<T> &mat, size_t ddof, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `ddof` Delta degrees of freedom.
* `rowwise` If `true`, return the standard deviation of the elements along each 
row. Otherwise, return the standard deviation of the elements along each 
column.

Returns

* A light-weight object with the standard deviation along an axis. Convertible 
to an array object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << np::stddev(mat, 0, true) << '\n';
    std::cout << "Column-wise: " << np::stddev(mat, 0, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [5.1173724, 4.6029882, 5.1234754]
Column-wise: [4.4969125, 8.7305339, 2.8674418, 3.7416574]
```

`quantile`

Return the q-th quantile of the array elements. 
```cpp
template <class T>
T quantile(const array<T> &arr, double q, const std::string &method = "linear");
```

Given an array of size `n`, the `q`-th quantile is the `(n - 1)*q`-th value of 
a sorted copy of the array. If `(n - 1)*q` is not an integer, the quantile is a 
weighted average of the two nearest neighbors. The different methods work as 
follows:

* `"lower"` Takes the lowest neighbor.
* `"higher"` Takes the highest neighbor.
* `"nearest"` Takes the nearest neighbor.
* `"midpoint"` Takes the average of both neighbors.
* `"linear"` Takes a linear interpolation between both neighbors.

Parameters

* `arr` An array-like object.
* `q` Quantile to compute, which must be between 0 and 1 (inclusive).
* `method` This parameter specifies the method to use for estimating the 
quantile. Must be one of `"lower"`, `"higher"`, `"nearest"`, `"midpoint"` or 
`"linear"`.

Returns

* The q-th quantile of the array elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << "95% confidence interval: [" 
              << np::quantile(arr, 0.025) << ", " << np::quantile(arr, 0.975) 
              << "]\n";
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
95% confidence interval: [-7.425, 11.55]
```

`quantile`

Return the q-th quantile of the matrix elements.
```cpp
template <class T>
T quantile(const matrix<T> &mat, double q, const std::string &method = "linear");
```

Parameters

* `mat` A matrix-like object.
* `q` Quantile to compute, which must be between 0 and 1 (inclusive).
* `method` This parameter specifies the method to use for estimating the 
quantile. Must be one of `"lower"`, `"higher"`, `"nearest`", `"midpoint"` or 
`"linear"`.

Returns

* The q-th quantile of the matrix elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "95% confidence interval: [" 
              << np::quantile(mat, 0.025) << ", " << np::quantile(mat, 0.975) 
              << "]\n";
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
95% confidence interval: [-7.075, 11.45]
```

`quantile`

Return the q-th quantile of the matrix elements along the specified axis.
```cpp
template <class T>
array<T> quantile(
    const matrix<T> &mat, double q, bool rowwise, 
    const std::string &method = "linear"
);
```

Parameters

* `mat` A matrix-like object.
* `q` Quantile to compute, which must be between 0 and 1 (inclusive).
* `rowwise` If `true`, return the quantile of the elements along each row. 
Otherwise, return the quantile of the elements along each column.
* `method` This parameter specifies the method to use for estimating the 
quantile. Must be one of `"lower"`, `"higher"`, `"nearest"`, `"midpoint"` or 
`"linear"`.

Returns

* A light-weight object with the q-th quantile along an axis. Convertible to an 
array object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "95% confidence interval:\n";
    std::cout << "Row-wise:\n" << np::quantile(mat, 0.025, true) << '\n' 
              << np::quantile(mat, 0.975, true) << '\n';
    std::cout << "Column-wise:\n" << np::quantile(mat, 0.025, false) << '\n' 
              << np::quantile(mat, 0.975, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
95% confidence interval:
Row-wise:
[-8.325, -1.325, -0.925]
[4.7, 9.85, 11.325]
Column-wise:
[0.05, -8.65, 0.15, -0.7]
[9.55, 11.3, 6.8, 7.85]
```

`percentile`

Return the q-th percentile of the array elements. The q-th percentile is 
defined as the q/100-th quantile.
```cpp
template <class T>
T percentile(const array<T> &arr, int q, const std::string &method = "linear");
```

Parameters

* `arr` An array-like object.
* `q` Percentile to compute, which must be between 0 and 100 (inclusive).
* `method` This parameter specifies the method to use for estimating the 
percentile. Must be one of `"lower"`, `"higher"`, `"nearest"`, `"midpoint"` or 
`"linear"`.

Returns

* The q-th percentile of the array elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << "1st quartile: " << np::percentile(arr, 25) << '\n';
    std::cout << "3rd quartile: " << np::percentile(arr, 75) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
1st quartile: 0.25
3rd quartile: 7.75
```

`percentile`

Return the q-th percentile of the matrix elements.
```cpp
template <class T>
T percentile(const matrix<T> &mat, int q, const std::string &method = "linear");
```

Parameters

* `mat` A matrix-like object.
* `q` Percentile to compute, which must be between 0 and 100 (inclusive).
* `method` This parameter specifies the method to use for estimating the 
percentile. Must be one of `"lower"`, `"higher"`, `"nearest"`, `"midpoint"` or 
`"linear"`.

Returns

* The q-th percentile of the matrix elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "1st quartile: " << np::percentile(mat, 25) << '\n';
    std::cout << "3rd quartile: " << np::percentile(mat, 75) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
1st quartile: -0.25
3rd quartile: 7.25
```

`percentile`

Return the q-th percentile of the matrix elements along the specified axis.
```cpp
template <class T>
array<T> percentile(
    const matrix<T> &mat, int q, bool rowwise, 
    const std::string &method = "linear"
);
```

Parameters

* `mat` A matrix-like object.
* `q` Percentile to compute, which must be between 0 and 100 (inclusive).
* `rowwise` If `true`, return the percentile of the elements along each row. 
Otherwise, return the percentile of the elements along each column.
* `method` This parameter specifies the method to use for estimating the 
percentile. Must be one of `"lower"`, `"higher"`, `"nearest"`, `"midpoint"` or 
`"linear"`.

Returns

* A light-weight object with the q-th percentile along an axis. Convertible to 
an array object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Row-wise:\n";
    std::cout << "1st quartile: " << np::percentile(mat, 25, true) << '\n';
    std::cout << "3rd quartile: " << np::percentile(mat, 75, true) << '\n';
    std::cout << "Column-wise:\n";
    std::cout << "1st quartile: " << np::percentile(mat, 25, false) << '\n';
    std::cout << "3rd quartile: " << np::percentile(mat, 75, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise:
1st quartile: [-2.25, 4.75, -0.25]
3rd quartile: [2, 8.5, 5.25]
Column-wise:
1st quartile: [0.5, -5.5, 1.5, 2]
3rd quartile: [5.5, 5, 5, 6.5]
```

`cov`

Return the covariance of two arrays.
```cpp
template <class T>
T cov(const array<T> &arr1, const array<T> &arr2, size_t ddof = 0);
```

The covariance is defined as the average of the element-wise products of the 
deviations from the mean:
```
cov(x, y) = mean((x - mean(x))*(y - mean(y)))
```

For complex types, the complex conjugate of `y` is used:
```
cov(x, y) = mean((x - mean(x))*conj(y - mean(y)))
```

The mean is calculated as `sum(*)/n`, where `n = x.size()`. However, if `ddof` 
is specified, the divisor `n - ddof` is used instead of `n`. 

Parameters

* `arr1` First array-like argument.
* `arr2` Second array-like argument.
* `ddof` Delta degrees of freedom.

Returns

* The covariance of the two arrays.

Exceptions

* `std::invalid_argument` Thrown if the array arguments have different sizes.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::cov(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
10.95
```

`cov`

Return the covariance matrix of given data.
```cpp
template <class T>
matrix<T> cov(const matrix<T> &mat, bool rowwise, size_t ddof = 0);
```

Parameters

* `mat` A matrix-like object containing multiple variables and observations.
* `rowwise` If `true`, then each row represents a variable, with observations 
in the columns. Otherwise, each column represents a variable, with observations 
in the rows.
* `ddof` Delta degrees of freedom.

Returns

* The covariance matrix of the variables. The element `(i, j)` is equal to the 
covariance of the `i`-th and `j`-th variables.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << np::cov(mat, false) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11],
 [1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1],
 [5, 3, 9, 0],
 [2, 11, 7, -3]]
```

Output

```
[[13.984375,  -7.84375,  4.109375,  3.171875],
 [ -7.84375,   73.6875,  20.40625,   3.15625],
 [ 4.109375,  20.40625, 12.984375,  8.046875],
 [ 3.171875,   3.15625,  8.046875, 32.359375]]
```

`corrcoef`

Return the Pearson's correlation coefficient of two arrays.
```cpp
template <class T>
T corrcoef(const array<T> &arr1, const array<T> &arr2);
```

The correlation coefficient is defined as the covariance of the two variables 
divided by the product of their standard deviations.
```
corr(x, y) = cov(x, y)/sqrt(var(x)*var(y))
```

Parameters

* `arr1` First array-like argument.
* `arr2` Second array-like argument.

Returns

* The correlaction coefficient of the two arrays.

Exceptions

* `std::invalid_argument` Thrown if the array arguments have different sizes.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::corrcoef(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
0.283639
```

`corrcoef`

Return the correlation matrix of given data.
```cpp
template <class T>
matrix<T> corrcoef(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object containing multiple variables and observations.
* `rowwise` If `true`, then each row represents a variable, with observations 
in the columns. Otherwise, each column represents a variable, with observations 
in the rows.

Returns

* The correlation matrix of the variables. The element `(i, j)` is equal to the 
correlation coefficient of the `i`-th and `j`-th variables.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << np::corrcoef(mat, false) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11],
 [1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1],
 [5, 3, 9, 0],
 [2, 11, 7, -3]]
```

Output

```
[[          1, -0.24434604,  0.30496059,  0.14910578],
 [-0.24434604,           1,   0.6597141, 0.064635992],
 [ 0.30496059,   0.6597141,           1,   0.3925696],
 [ 0.14910578, 0.064635992,   0.3925696,           1]]
```

## Basic linear algebra

`inner`

Return the inner product of two arrays. 
```cpp
template <class T>
T inner(const array<T> &lhs, const array<T> &rhs);
```

For real arrays, the inner product is defined as the sum of the element-wise 
products of the two arrays: 
```
inner(a, b) = sum(a * b)
```
For complex arrays, the complex conjugate of the first argument is used: 
```
inner(a, b) = sum(conj(a) * b)
```

Parameters

* `lhs` Left-hand side array-like object.
* `rhs` Right-hand side array-like object.

Returns

* The inner product of the two arrays.

Exceptions

* `std::invalid_argument` Thrown if the sizes do not match.

Example

```cpp
#include <iostream>
#include <complex>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array< std::complex<double> > arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::inner(arr1, arr2) << '\n';
    std::cout << np::inner(arr2, arr1) << '\n';
    return 0;
}
```

Input

```
[(12, 1), (5, -9), (-1, 5), (3, 10), (7, -2)]
[(7, 2), (9, 8), (12, 17), (-1, -6), (3, 0)]
```

Output

```
(90,59)
(90,-59)
```

`outer`

Return the outer product of two arrays.
```cpp
template <class T>
matrix<T> outer(const array<T> &lhs, const array<T> &rhs);
```

The outer product of two arrays is defined as the matrix whose element `(i, j)` 
is equal to the product of the `i`-th and `j`-th elements of both arrays.

Parameters

* `lhs` Left-hand side array-like object.
* `rhs` Right-hand side array-like object.

Returns

* A light-weight object with the outer product of the two arrays. Convertible 
to a matrix object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::outer(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[2, 3, 4]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Output

```
[[ 2,  4,  6,  8, 10, 12, 14, 16, 18],
 [ 3,  6,  9, 12, 15, 18, 21, 24, 27],
 [ 4,  8, 12, 16, 20, 24, 28, 32, 36]]
```

`dot`

Return the dot product of two arrays or the matrix multiplication of two 
matrices.
```cpp
template <class T>
T dot(const array<T> &lhs, const array<T> &rhs);

template <class T>
matrix<T> dot(const matrix<T> &lhs, const matrix<T> &rhs);

template <class T>
array<T> dot(const array<T> &lhs, const matrix<T> &rhs);

template <class T>
array<T> dot(const matrix<T> &lhs, const array<T> &rhs);
```

If both arguments are arrays, return the inner product of the arrays (without 
complex conjugation).

If both arguments are matrices, return the matrix multiplication of the 
matrices.

If the first argument is an array and the second argument is a matrix, return 
the matrix multiplication with the array treated as a row vector.

If the first argument is a matrix and the second argument is an array, return 
the matrix multiplication with the array treated as a column vector.

The matrix multiplication is the matrix whose element `(i, j)` is equal to the 
inner product (without complex conjugation) of the `i`-th row of the first 
argument and the `j`-th column of the second argument.

Parameters

* `lhs` Left-hand side array-like or matrix-like object.
* `rhs` Right-hand side array-like or matrix-like object.

Returns

* The dot product or matrix multiplication of the arguments.

Exceptions

* `std::invalid_argument` Thrown if the number of columns in the first argument 
do not match the number of rows in the second argument.
* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::dot(arr1, arr2) << '\n';
    np::matrix<double> mat1, mat2;
    std::cin >> mat1 >> mat2;
    std::cout << np::dot(mat1, mat2) << '\n';
    return 0;
}
```

Input

```
[1, 5, 2, 0, 1]
[7, -1, 2, 8, 3]
[[7, 1, 8, -1],
 [3, 2, 5, 12],
 [10, 0, 3, -2]]
[[1, 7],
 [5, -1],
 [2, 2],
 [0, 8]]
```

Output

```
9
[[ 28,  56],
 [ 23, 125],
 [ 16,  60]]
```

`kron`

Return the Kronecker product of two matrices.
```cpp
template <class T>
matrix<T> kron(const matrix<T> &lhs, const matrix<T> &rhs);
```

If `A` is an `m x n` matrix and `B` is a `p x q` matrix, the Kronecker product 
of `A` and `B` is the `pm x qn` block matrix:
```
[[    A[0, 0]*B,     A[0, 1]*B, ... ,     A[0, n - 1]*B],
 [    A[1, 0]*B,     A[1, 1]*B, ... ,     A[1, n - 1]*B],
 ...
 [A[m - 1, 0]*B, A[m - 1, 1]*B, ... , A[m - 1, n - 1]*B]]
```

Parameters

* `lhs` Left-hand side matrix-like object.
* `rhs` Right-hand side matrix-like object.

Returns

* A light-weight object with the Kronecker product of the two matrices. 
Convertible to a matrix object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat1, mat2;
    std::cin >> mat1 >> mat2;
    std::cout << np::kron(mat1, mat2) << '\n';
    return 0;
}
```

Input

```
[[1, 2],
 [3, 4]]
[[0, 5], 
 [6, 7]]
```

Output

```
[[ 0,  5,  0, 10],
 [ 6,  7, 12, 14],
 [ 0, 15,  0, 20],
 [18, 21, 24, 28]]
```

`cross`

Return the cross product of two arrays.
```cpp
template <class T>
array<T> cross(const array<T> &lhs, const array<T> &rhs);
```

The cross product of two vectors `a` and `b` (in R<sup>3</sup>) is a vector 
perpendicular to both `a` and `b`. When the dimension of either `a` or `b` is 
2, the third component of the vector is assumed to be zero.

Parameters

* `lhs` Left-hand side array-like object.
* `rhs` Right-hand side array-like object.

Returns

* The cross product of the arrays.

Exceptions

* `std::invalid_argument` Thrown if the size of the arrays is neither 2 nor 3.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::cross(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3]
[4, 5, 6]
```

Output

```
[-3, 6, -3]
```

`transpose`

Return the transpose of a matrix.

Parameters

* `mat` A matrix-like object.

Returns

* A light-weight object with the matrix transposed. Convertible to a matrix 
object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << np::transpose(mat) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
[[ 1,  5,  9],
 [ 2,  6, 10],
 [ 3,  7, 11],
 [ 4,  8, 12]]
```

`conj_transpose`

Return the complex conjugate transpose of a matrix.

Parameters

* `mat` A matrix-like object.

Returns

* A light-weight object with the conjugate transposed matrix. If `T` is not a 
complex type, the function returns the matrix transposed.

Example

```cpp
#include <iostream>
#include <complex>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix< std::complex<double> > mat;
    std::cin >> mat;
    std::cout << np::conj_transpose(mat) << '\n';
    return 0;
}
```

Input

```
[[(1,0), (-9,3), (0,-1), (5,2)],
 [(10,-3), (-2,5), (7,-10), (8,8)],
 [(0,0), (12,10), (3,11), (-1,7)]]
```

Output

```
[[  (1,-0),   (10,3),   (0,-0)],
 [ (-9,-3),  (-2,-5), (12,-10)],
 [   (0,1),   (7,10),  (3,-11)],
 [  (5,-2),   (8,-8),  (-1,-7)]]
```

`norm`

Return the vector norm.
```cpp
/// Non-complex types
template <class T>
T norm(const array<T> &arr, double p = 2);
/// Complex types
T norm(const array< std::complex<T> > &arr, double p = 2);
```

This function is able to return one of the following norms:

| Order  | Definition              |
| ------ | ----------------------- |
| `p`    | `sum(abs(x)**p)**(1/p)` |
| `0`    | `count_nonzero(x)`      |
| `inf`  | `max(abs(x))`           |
| `-inf` | `min(abs(x))`           |

Parameters

* `arr` An array-like object.
* `p` Order of the norm. The default is 2 (Euclidean norm). For values of 
`p < 1`, the result is, strictly speaking, not a mathematical norm, but it may 
still be useful for various numerical purposes.

Returns

* Norm of the array.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/math.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    double inf = np::constants<double>::inf;
    np::array<double> arr;
    std::cin >> arr;
    std::cout << "2 norm: " << np::norm(arr) << '\n';
    std::cout << "1 norm: " << np::norm(arr, 1) << '\n';
    std::cout << "3 norm: " << np::norm(arr, 3) << '\n';
    std::cout << "inf norm: " << np::norm(arr, inf) << '\n';
    std::cout << "-inf norm: " << np::norm(arr, -inf) << '\n';
    std::cout << "0 norm: " << np::norm(arr, 0) << '\n';
    return 0;
}
```

Input

```
[1, 5, 2, 0, 1]
```

Output

```
2 norm: 5.56776
1 norm: 9
3 norm: 5.12993
inf norm: 5
-inf norm: 0
0 norm: 4
```

`trace`

Return the sum along a diagonal of the matrix, i.e., the sum of the elements 
`a(i, i + offset)` for all `i`.
```cpp
template <class T>
T trace(const matrix<T> &mat, ptrdiff_t offset = 0);
```

Parameters

* `mat` A matrix-like object.
* `offset` Offset of the diagonal from the main diagonal. A positive value 
refers to an upper diagonal and a negative value refers to a lower diagonal. 
Defaults to main diagonal (0).

Returns

* The sum along the diagonal.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Main diagonal: " << np::trace(mat) << '\n';
    std::cout << "Subdiagonal: " << np::trace(mat, -1) << '\n';
    std::cout << "Superdiagonal: " << np::trace(mat, 1) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1],
 [-3, 5, 0, -7]]
```

Output

```
Main diagonal: -5
Subdiagonal: 22
Superdiagonal: -3
```

## Set operations

`unique`

Find the unique elements of an array.
```cpp
template <class T>
array<T> unique(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* A new array with the sorted unique values.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::unique(arr) << '\n';
    return 0;
}
```

Input

```
[0, 1, 1, 2, 2, 2, 3, 5, 7, 7]
```

Output

```
[0, 1, 2, 3, 5, 7]
```

`includes`

Test whether a value is present in an array.
```cpp
template <class T>
bool includes(const array<T> &arr, const T &val);
```

Parameters

* `arr` An array-like object. The function tests whether `arr` contains `val`. 
It must be sorted.
* `val` The value to test.

Returns

* A `bool` with the result of the test.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr, val;
    std::cin >> arr >> val;
    std::cout << std::boolalpha;
    for (unsigned i = 0; i < val.size(); ++i) {
        std::cout << val[i] << ": " << np::includes(arr, val[i]) << '\n';
    }
    return 0;
}
```

Input

```
[0, 1, 2, 3, 5, 7]
[1, 2, 4, 8]
```

Output

```
1: true
2: true
4: false
8: false
```

`includes`

Test whether all the elements of an array are also present in another array.
```cpp
template <class T>
bool includes(const array<T> &arr, const array<T> &val);
```

Parameters

* `arr` An array-like object. The function tests whether `arr` contains all the 
elements of `val`. It must be sorted.
* `val` An array-like object with the elements to test. It must be sorted.

Returns

* A `bool` with the results of the test.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr, val;
    std::cin >> arr >> val;
    std::cout << std::boolalpha << np::includes(arr, val) << '\n';
    return 0;
}
```

Input

```
[0, 1, 2, 3, 5, 7]
[1, 2, 4, 8]
```

Output

```
false
```

`set_union`

Return a new array with the unique, sorted elements that are present in either 
one of the two arrays, or in both.
```cpp
template <class T>
array<T> set_union(const array<T> &arr1, const array<T> &arr2);
```

Parameters

* `arr1` An array-like object. It must be sorted.
* `arr2` An array-like object. It must be sorted.

Returns

* An array with the set union of the two arrays.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::set_union(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[0, 1, 2, 3, 5, 7]
[1, 2, 4, 5, 6, 8]
```

Output

```
[0, 1, 2, 3, 4, 5, 6, 7, 8]
```

`set_intersection`

Return a new array with the unique, sorted elements that are present in both 
arrays.
```cpp
template <class T>
array<T> set_intersection(const array<T> &arr1, const array<T> &arr2);
```

Parameters

* `arr1` An array-like object. It must be sorted.
* `arr2` An array-like object. It must be sorted.

Returns

* An array with the set intersection of the two arrays.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::set_intersection(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[0, 1, 2, 3, 5, 7]
[1, 2, 4, 5, 6, 8]
```

Output

```
[1, 2, 5]
```

`set_difference`

Return a new array with the unique, sorted elements that are present in the 
first array, but not in the second.
```cpp
template <class T>
array<T> set_difference(const array<T> &arr1, const array<T> &arr2);
```

Parameters

* `arr1` An array-like object. It must be sorted.
* `arr2` An array-like object. It must be sorted.

Returns

* An array with the set difference of the two arrays.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::set_difference(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[0, 1, 2, 3, 5, 7]
[1, 2, 4, 5, 6, 8]
```

Output

```
[0, 3, 7]
```

`set_symmetric_difference`

Return a new array with the unique, sorted elements that are present in one of 
the two arrays, but not in both.
```cpp
template <class T>
array<T> set_symmetric_difference(const array<T> &arr1, const array<T> &arr2);
```

Parameters

* `arr1` An array-like object. It must be sorted.
* `arr2` An array-like object. It must be sorted.

Returns

* An array with the set symmetric difference of the two arrays.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an 
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/routines.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::set_symmetric_difference(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[0, 1, 2, 3, 5, 7]
[1, 2, 4, 5, 6, 8]
```

Output

```
[0, 3, 4, 6, 7, 8]
```
# Broadcasting

Defined in: `numcpp/broadcasting.h`

## Content
- [Broadcasting](#broadcasting)
  - [Content](#content)
  - [Broadcasting](#broadcasting-1)
  - [Creation routines from existing data](#creation-routines-from-existing-data)
  - [Basic manipulation routines](#basic-manipulation-routines)
  - [Indexing routines](#indexing-routines)
  - [Functional programming](#functional-programming)

-----

## Broadcasting

`broadcast_to`

Broadcast a value to an array.

Return a readonly `array_view` of given size filled with `val`. This function
does not create a new array, instead, it broadcasts the given value as an array
of given size. All the elements in the broadcasted array refer to the same
memory location.
```cpp
template <class T>
const array_view<T> broadcast_to(T &val, size_t n);
```

Parameters

* `val` A reference to the fill value.
* `n` Length of array.

Returns

* A readonly view of the original value with the given size.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    int val;
    size_t n;
    std::cin >> val >> n;
    std::cout << np::broadcast_to(val, n) << '\n';
    return 0;
}
```

Input

```
0 10
```

Output

```
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

`broadcast_to`

Broadcast a value to a matrix.

Return a readonly `matrix_view` of given size filled with `val`. This function
does not create a new matrix, instead, it broadcasts the given value as a
matrix of given size. All the elements in the broadcasted matrix refer to the
same memory location.
```cpp
template <class T>
const matrix_view<T> broadcast_to(T &val, size_t m, size_t n);
```

Parameters

* `val` A reference to the fill value.
* `m` Number of rows.
* `n` Number of columns.

Returns

* A readonly view of the original value with the given number of rows and
columns.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    int val;
    size_t m, n;
    std::cin >> val >> m >> n;
    std::cout << np::broadcast_to(val, m, n) << '\n';
    return 0;
}
```

Input

```
0 3 4
```

Output

```
[[0, 0, 0, 0],
 [0, 0, 0, 0],
 [0, 0, 0, 0]]
```

`broadcast_to`

Broadcast an array to a matrix.

Return a readonly `matrix_view` constructed by repeating an array a given
number of times. This function does not create a new matrix, instead, it
broadcasts the given array as a matrix of given size. Some elements in the
broadcasted matrix may refer to the same memory location.
```cpp
template <class T>
const matrix_view<T> broadcast_to(
    array<T> &arr, size_t reps, bool row_major = true
);

template <class T>
const matrix_view<T> broadcast_to(
    array_view<T> &arr, size_t reps, bool row_major = true
);
```

Parameters

* `arr` A reference to an [`array`](1.%20Array.md) or
[`array_view`](1.1%20Array%20view.md) object.
* `reps` The number of repetitions of `arr` along the new axis.
* `row_major` If `true` (default), the array is tiled across each row.
Otherwise, the array is tiled across each column.

Returns

* A read only view of the original array with the given size.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    size_t reps;
    std::cin >> arr >> reps;
    std::cout << "Row-major:\n" << np::broadcast_to(arr, reps, true) << '\n';
    std::cout << "Column-major:\n" << np::broadcast_to(arr, reps, false) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5]
3
```

Output

```
Row-major:
[[1, 2, 3, 4, 5],
 [1, 2, 3, 4, 5],
 [1, 2, 3, 4, 5]]
Column-major:
[[1, 1, 1],
 [2, 2, 2],
 [3, 3, 3],
 [4, 4, 4],
 [5, 5, 5]]
```

## Creation routines from existing data

`asarray`

Convert the input to an [`array`](1.%20Array.md).
```cpp
template <class Container, class T = typename Container::value_type>
array<T> asarray(const Container &data);

template <class T, size_t N>
array<T> asarray(const T (&data)[N]);

template <class T>
array<T> asarray(std::initializer_list<T> data);

template <class T>
array<T>& asarray(array<T> &data);
```

Parameters

* `data` Input data, in any container form. This includes static arrays,
[`std::vector`](https://en.cppreference.com/w/cpp/container/vector),
[`std::list`](https://en.cppreference.com/w/cpp/container/list),
[`std::set`](https://en.cppreference.com/w/cpp/container/set), etc.

Returns

* Array interpretation of the data. No copy is performed if the input is
already an `array`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include <vector>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    // From std::vector.
    std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    arr = np::asarray(v);
    std::cout << arr << '\n';
    // From static array.
    int a[10] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
    arr = np::asarray(a);
    std::cout << arr << '\n';
    // From std::initializer_list.
    arr = np::asarray({20, 21, 22, 23, 24, 25, 26, 27, 28, 29});
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
```

`asmatrix`

Convert the input to a [`matrix`](2.%20Matrix.md).
```cpp
template <class Container, class T = typename Container::value_type>
matrix<T> asmatrix(const Container &data, size_t n = 1);

template <class T, size_t M, size_t N>
matrix<T> asmatrix(const T (&data)[M][N], size_t n = 1);

template <class T>
matrix<T> asmatrix(
    std::initializer_list< std::initializer_list<T> > data, size_t n = 1
);

template <class T>
matrix<T>& asmatrix(matrix<T> &data, size_t n = 1);
```

Parameters

* `data` Input data, in any container form. This includes static arrays,
[`std::vector`](https://en.cppreference.com/w/cpp/container/vector),
[`std::list`](https://en.cppreference.com/w/cpp/container/list),
[`std::set`](https://en.cppreference.com/w/cpp/container/set), etc. The input
must be one dimensional, except for static arrays, `matrix` and
`std::initializer_list`.
* `n` Number of columns. The number of rows is inferred from the length of the
data. Ignored if the input is already two dimensional. Defaults to 1.

Returns

* Matrix interpretation of the data. No copy is performed if the input is
already a `matrix`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include <vector>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    // From std::vector.
    std::vector<int> v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    mat = np::asmatrix(v, 5);
    std::cout << mat << '\n';
    // From static array.
    int a[2][5] = {{10, 11, 12, 13, 14}, {15, 16, 17, 18, 19}};
    mat = np::asmatrix(a);
    std::cout << mat << '\n';
    // From std::initializer_list.
    mat = np::asmatrix({{20, 21, 22, 23, 24}, {25, 26, 27, 28, 29}});
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[0, 1, 2, 3, 4],
 [5, 6, 7, 8, 9]]
[[10, 11, 12, 13, 14],
 [15, 16, 17, 18, 19]]
[[20, 21, 22, 23, 24],
 [25, 26, 27, 28, 29]]
 ```

`copy`

Return a copy of an array.
```cpp
template <class T>
array<T> copy(const array<T> &arr);
```

Parameters

* `arr` Array-like object to copy.

Returns

* A copy of `arr`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    // Because arr[arr > 0] is a view of arr,
    // arr = arr[arr > 0];
    // might result in undefined behaviour, and so a copy needs to be created.
    arr = np::copy(arr[arr > 0]);
    std::cout << arr << '\n';
    return 0;
}
```

Input

```
[4, -1, 0, 5, 7, -3, 10, -2, 9, -5]
```

Output

```
[4, 5, 7, 10, 9]
```

`copy`

Return a copy of a matrix.
```cpp
template <class T>
matrix<T> copy(const matrix<T> &mat);
```

Parameters

* `mat` Matrix-like object to copy.

Returns

* A copy of `mat`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    // Because mat.t() is a view of mat
    // mat = mat.t();
    // might result in undefined behaviour, and so a copy needs to be created.
    mat = np::copy(mat.t());
    std::cout << mat << '\n';
    return 0;
}
```

Input

```
[[4, -1, 0, 5],
 [7, -3, 10, -2],
 [9, -5, 8, 1]]
```

Output

```
[[ 4,  7,  9],
 [-1, -3, -5],
 [ 0, 10,  8],
 [ 5, -2,  1]]
```

`flatten`

Return a copy of the matrix collapsed into an array.
```cpp
template <class T>
array<T> flatten(const matrix<T> &mat);

template <class T>
array<T> flatten(const matrix<T> &mat, bool row_major);
```

Parameters

* `mat` Matrix-like object to flatten.
* `row_major` Whether to flatten the elements in row-major order or
column-major order. Defaults to the same order as stored in memory.

Returns

* The flattened matrix.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-major order:\n" << np::flatten(mat, true) << '\n';
    std::cout << "Column-major order:\n" << np::flatten(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-major order:
[1, -9, 0, 5, 10, -2, 7, 8, 0, 12, 3, -1]
Column-major order:
[1, 10, 0, -9, -2, 12, 0, 7, 3, 5, 8, -1]
```

## Basic manipulation routines

`astype`

Cast each element in an array to a specified type.
```cpp
template <class U, class T>
array<U> astype(const array<T> &arr);
```

Template parameters

* `U` Data type to which the array is cast.

Parameters

* `arr` Array-like object to cast.

Returns

* A light-weight object with the elements in the array casted to the specified
type. Convertible to an [`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << np::astype<int>(arr) << '\n';
    return 0;
}
```

Input

```
[0.1, -1., 6.33, 0.5, 9.8, 7., 1.2, 0., -5.3, 2.1]
```

Output

```
[0, -1, 6, 0, 9, 7, 1, 0, -5, 2]
```

`astype`

Cast each element in a matrix to a specified type.
```cpp
template <class U, class T>
matrix<U> astype(const matrix<T> &mat);
```

Template parameters

* `U` Data type to which the matrix is cast.

Parameters

* `mat` Matrix-like object to cast.

Returns

* A light-weight object with the elements in the matrix casted to the specified
type. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << np::astype<int>(mat) << '\n';
    return 0;
}
```

Input

```
[[0.1, -1, 6.33, 0.5],
 [-2.3, 9.8, 7, 1.2],
 [0, -5.3, 2.1, 12.7]]
```

Output

```
[[ 0, -1,  6,  0],
 [-2,  9,  7,  1],
 [ 0, -5,  2, 12]]
```

`zip`

Return an array of pairs with each element constructed from the corresponding
elements in two array objects.
```cpp
template <class T, class U>
array< std::pair<T, U> > zip(const array<T> &arr1, const array<U> &arr2);
```

Parameters

* `arr1` First array-like argument.
* `arr2` Second array-like argument.

Returns

* A light-weight object with the elements in two array arguments zipped as a
pair. Convertible to an [`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io/tuple.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1;
    np::array<double> arr2;
    std::cin >> arr1 >> arr2;
    std::cout << np::zip(arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[1, 0.5, 0.333333, 0.25, 0.2, 0.166666, 0.142857, 0.125, 0.111111, 0.1]
```

Output

```
[(1,1), (2,0.5), (3,0.333333), (4,0.25), (5,0.2), (6,0.166666), (7,0.142857),
 (8,0.125), (9,0.111111), (10,0.1)]
```

`zip`

Return a matrix of pairs with each element constructed from the corresponding
elements in two matrix objects.
```cpp
template <class T, class U>
matrix< std::pair<T, U> > zip(const matrix<T> &mat1, const matrix<U> &mat2);
```

Parameters

* `mat1` First matrix-like argument.
* `mat2` Second matrix-like argument.

Returns

* A light-weight object with the elements in two matrix arguments zipped as a
pair. Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io/tuple.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1;
    np::matrix<double> mat2;
    std::cin >> mat1 >> mat2;
    std::cout << np::zip(mat1, mat2) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
  [9, 10, 11, 12]]
[[1, 0.5, 0.333333, 0.25],
 [0.2, 0.166666, 0.142857, 0.125],
 [0.111111, 0.1, 0.090909, 0.083333]]
```

Output

```
[[        (1,1),       (2,0.5),  (3,0.333333),      (4,0.25)],
 [      (5,0.2),  (6,0.166666),  (7,0.142857),     (8,0.125)],
 [ (9,0.111111),      (10,0.1), (11,0.090909), (12,0.083333)]]
```

`unzip`

Return an array with each element constructed from taking the `I`-th element of
the corresponding pair in an array object.
```cpp
template <size_t I, class T, class U>
array<typename std::tuple_element< I, std::pair<T, U> >::type>
unzip(const array< std::pair<T, U> > &arr);
```

Template parameters

* `I` Element index.

Parameters

* `arr` An array-like object of pairs.

Returns

* A light-weight object with the `I`-th element of each pair in the array.
Convertible to an [`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include <utility>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io/tuple.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array< std::pair<int, double> > arr;
    std::cin >> arr;
    std::cout << np::unzip<0>(arr) << '\n';
    std::cout << np::unzip<1>(arr) << '\n';
    return 0;
}
```

Input

```
[(1,1), (2,0.5), (3,0.333333), (4,0.25), (5,0.2), (6,0.166666), (7,0.142857),
 (8,0.125), (9,0.111111), (10,0.1)]
```

Output

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[1, 0.5, 0.333333, 0.25, 0.2, 0.166666, 0.142857, 0.125, 0.111111, 0.1]
```

`unzip`

Return a matrix with each element constructed from taking the `I`-th element of
the corresponding pair in a matrix object.
```cpp
template <size_t I, class T, class U>
matrix<typename std::tuple_element< I, std::pair<T, U> >::type>
unzip(const matrix< std::pair<T, U> > &mat);
```

Template parameters

* `I` Element index.

Parameters

* `mat` A matrix-like object of pairs.

Returns

* A light-weight object with the `I`-th element of each pair in the matrix.
Convertible to a [`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include <utility>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io/tuple.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix< std::pair<int, double> > mat;
    std::cin >> mat;
    std::cout << np::unzip<0>(mat) << '\n';
    std::cout << np::unzip<1>(mat) << '\n';
    return 0;
}
```

Input

```
[[(1,1), (2,0.5), (3,0.333333), (4,0.25)],
 [(5,0.2), (6,0.166666), (7,0.142857), (8,0.125)],
 [(9,0.111111), (10,0.1), (11,0.090909), (12,0.083333)]]
```

Output

```
[[ 1,  2,  3,  4],
 [ 5,  6,  7,  8],
 [ 9, 10, 11, 12]]
[[       1,      0.5, 0.333333,     0.25],
 [     0.2, 0.166666, 0.142857,    0.125],
 [0.111111,      0.1, 0.090909, 0.083333]]
```

`reverse`

Return the elements of an array in reversed order.
```cpp
template <class T>
array<T> reverse(const array<T> &arr);
```

Parameters

* `arr` An array-like object.

Returns

* A light-weight object with the elements in reversed order. Convertible to an
[`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::reverse(arr) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
[3, -1, 12, 9, 7, -2, 10, 5, -9, 1]
```

`reverse`

Return the elements of a matrix in reversed order along an axis.
```cpp
template <class T>
matrix<T> reverse(const matrix<T> &mat, bool rowwise);
```

Parameters

* `mat` A matrix-like object.
* `rowwise` If `true`, reverse the elements along each row. Otherwise, reverse
the elements along each column.

Returns

* A light-weight object with the elements in reversed order. Convertible to a
[`matrix`](2.%20Matrix.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise:\n" << np::reverse(mat, true) << '\n';
    std::cout << "Column-wise:\n" << np::reverse(mat, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise:
[[ 5,  0, -9,  1],
 [ 8,  7, -2, 10],
 [-1,  3, 12,  0]]
Column-wise:
[[ 0, 12,  3, -1],
 [10, -2,  7,  8],
 [ 1, -9,  0,  5]]
```

`rot90`

Rotate a matrix by 90 degrees.
```cpp
template <class T>
matrix<T> rot90(const matrix<T> &mat, int times = 1);
```

Parameters

* `mat` A matrix-like object.
* `times` Number of times the matrix is rotated by 90 degrees. A positive value
indicates the matrix is rotated clockwise and a negative value indicates the
matrix is rotated counter clockwise. Defaults to 1.

Returns

* The rotated matrix.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    for (int times = 0; times < 4; ++times){
        std::cout << times << " times:\n" << np::rot90(mat, times) << '\n';
    }
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
0 times:
[[ 1, -9,  0,  5],
 [10, -2,  7,  8],
 [ 0, 12,  3, -1]]
1 times:
[[ 0, 10,  1],
 [12, -2, -9],
 [ 3,  7,  0],
 [-1,  8,  5]]
2 times:
[[-1,  3, 12,  0],
 [ 8,  7, -2, 10],
 [ 5,  0, -9,  1]]
3 times:
[[ 5,  8, -1],
 [ 0,  7,  3],
 [-9, -2, 12],
 [ 1, 10,  0]]
```

## Indexing routines

`ravel_multi_index`

Converts a pair of indices into a flat index.
```cpp
size_t ravel_multi_index(
    size_t i, size_t j, size_t m, size_t n, bool row_major = true
);

size_t ravel_multi_index(
    const index_t &multi_index, size_t m, size_t n, bool row_major = true
);
```

Parameters

* `multi_index` The indices to flatten. It can be either an `index_t` object
or two `size_t` arguments.
* `m` Number of rows.
* `n` Number of columns.
* `row_major` Determines whether the indices should be viewed as indexing in
row-major order or column-major order. Defaults to row-major order.

Returns

* The flattened index.

`ravel_multi_index`

Converts a pair of indices into a flat index.
```cpp
array<size_t> ravel_multi_index(
    const array<index_t> &multi_index,
    size_t m, size_t n, bool row_major = true
);
```

Parameters

* `multi_index` An array-like object of `index_t` with the indices to flatten.
* `m` Number of rows.
* `n` Number of columns.
* `row_major` Determines whether the indices should be viewed as indexing in
row-major order or column-major order. Defaults to row-major order.

Returns

* A light-weight object with the flattened indices. Convertible to an
[`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io/tuple.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    np::array<np::index_t> indices = np::where(mat > 0);
    std::cout << indices << '\n';
    std::cout << np::ravel_multi_index(indices, mat.rows(), mat.cols()) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
[(0,0), (0,3), (1,0), (1,2), (1,3), (2,1), (2,2)]
[0, 3, 4, 6, 7, 9, 10]
```

`unravel_index`

Converts a flat index into a pair of indices.
```cpp
index_t unravel_index(
    size_t index, size_t m, size_t n, bool row_major = true
);
```

Parameters

* `index` A flat index.
* `m` Number of rows.
* `n` Number of columns.
* `row_major` Determines whether the indices should be viewed as indexing in
row-major order or column-major order. Defaults to row-major order.

Returns

* The unraveled index.

`unravel_index`

Converts a flat index into a pair of indices.
```cpp
array<index_t> unravel_index(
    const array<size_t> &index,
    size_t m, size_t n, bool row_major = true
);
```

Parameters

* `index` An array-like object of `size_t` with the flat indices.
* `m` Number of rows.
* `n` Number of columns.
* `row_major` Determines whether the indices should be viewed as indexing in
row-major order or column-major order. Defaults to row-major order.

Returns

* A light-weight object with the unraveled indices. Convertible to an
[`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/routines.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io/tuple.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    np::array<size_t> indices = np::where(mat.flatten() > 0);
    std::cout << indices << '\n';
    std::cout << np::unravel_index(indices, mat.rows(), mat.cols()) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
[0, 3, 4, 6, 7, 9, 10]
[(0,0), (0,3), (1,0), (1,2), (1,3), (2,1), (2,2)]
```

`take`

Take elements from an array. When an [`array`](1.%20Array.md) object is given,
a call such as `np::take(arr, indices)` is equivalent to `arr[indices]`, except
that a copy is always returned.
```cpp
template <class T>
array<T> take(const array<T> &arr, const array<size_t> &indices);
```

Parameters

* `arr` The source array.
* `indices` An array-like object of `size_t` with the indices of the values to
take.

Returns

* A new array with the elements from `arr` at the given positions.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    np::array<size_t> indices;
    std::cin >> arr >> indices;
    std::cout << np::take(arr, indices) << '\n';
    return 0;
}
```

Input

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
[1, 2, 3, 5, 8]
```

Output

```
[5, -1, 3, 2, -6]
```

`take`

Take elements from a matrix. When a [`matrix`](2.%20Matrix.md) object is given,
a call such as `np::take(mat, indices)` is equivalent to `mat[indices]`, except
that a copy is always returned.
```cpp
template <class T>
array<T> take(const matrix<T> &mat, const array<index_t> &indices);
```

Parameters

* `mat` The source matrix.
* `indices` An array-like object of `index_t` with the indices of the values to
take.

Returns

* A new array with the elements from `mat` at the given positions.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io/tuple.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    np::array<np::index_t> indices;
    std::cin >> mat >> indices;
    std::cout << np::take(mat, indices) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
[(0, 0), (0, 2), (1, 3), (2, 1)]
```

```
[10, 5, 6, -5]
```

`take`

Take elements from a matrix along an axis.
```cpp
template <class T>
array<T> take(const matrix<T> &mat, size_t index, bool rowwise);

template <class T>
matrix<T> take(
    const matrix<T> &mat, const array<size_t> &indices, bool rowwise
);
```

Parameters

* `mat` The source matrix.
* `indices` A single index or an array-like object of `size_t` with the indices
of the values to take.
* `rowwise` If `true`, take elements along each row. Otherwise, take elements
along each column.

Returns

* A new array if a single index is given, or a new matrix if an array of
indices is given, with the elements from `mat` at the given positions.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    np::array<size_t> indices;
    std::cin >> mat;
    std::cin >> indices;
    std::cout << "Row-wise:\n" << np::take(mat, indices, true) << '\n';
    std::cin >> indices;
    std::cout << "Column-wise:\n" << np::take(mat, indices, false) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
[0, 3]
[0, 2]
```

Output

```
Row-wise:
[[ 10,   3],
 [  7,   6],
 [  8, -11]]
Column-wise:
[[ 10,  -1,   5,   3],
 [  8,  -5,   1, -11]]
```

`take_along_axis`

Take values from the input matrix by matching 1d index and data slices.
Functions returning an index along an axis, like
[`argsort`](4.%20Routines.md#sorting-and-searching) and
[`argpartition`](4.%20Routines.md#sorting-and-searching), produce suitable
indices for this function.
```cpp
template <class T>
matrix<T> take_along_axis(
    const matrix<T> &mat, const matrix<size_t> &indices, bool rowwise
);
```

Parameters

* `mat` The source matrix.
* `indices` A matrix-like object of `size_t` with the indices to take along
each 1d slice of `mat`.
* `rowwise` If `true`, match indices along each row. Otherwise, match indices
along each column.

Returns

* A new matrix with the elements from `mat` at the given positions.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    np::matrix<size_t> indices;
    std::cin >> mat;
    std::cin >> indices;
    std::cout << "Row-wise:\n"
              << np::take_along_axis(mat, indices, true) << '\n';
    std::cin >> indices;
    std::cout << "Column-wise:\n"
              << np::take_along_axis(mat, indices, false) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
[[1, 0],
 [3, 1],
 [3, 0]]
[[1, 2, 2, 2],
 [0, 1, 1, 1]]
```

Output

```
Row-wise:
[[ -1,  10],
 [  6,  17],
 [-11,   8]]
Column-wise:
[[  7,  -5,   1, -11],
 [ 10,  17,  11,   6]]
```

`put`

Replaces specified elements of an array with given values. When an
[`array`](1.%20Array.md) object is given, a call such as
`np::put(arr, indices, values)` is equivalent to `arr[indices] = values`.
```cpp
template <class T>
void put(array<T> &arr, const array<size_t> &indices, const array<T> &values);

template <class T>
void put(
    array<T> &arr, const array<size_t> &indices,
    const typename array<T>::value_type &value
);
```

Parameters

* `arr` Target array.
* `indices` Target indices.
* `values` A single value or an array of values to put into `arr` at target
indices.

Returns

* None

Exceptions

* `std::invalid_argument` Thrown if `indices` and `values` have different sizes.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    np::array<size_t> indices;
    np::array<int> values;
    std::cin >> arr >> indices >> values;
    np::put(arr, indices, values);
    std::cout << arr << '\n';
    return 0;
}
```

Input

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
[1, 2, 3, 5, 8]
[10, 20, 30, 40, 50]
```

Output

```
[12, 10, 20, 30, 7, 40, 8, 17, 50, 0]
```

`put`

Replaces specified elements of a matrix with given values. When a
[`matrix`](2.%20Matrix.md) object is given, a call such as
`np::put(mat, indices, values)` is equivalent to `mat[indices] = values`.
```cpp
template <class T>
void put(matrix<T> &mat, const array<index_t> &indices, const array<T> &values);

template <class T>
void put(
    matrix<T> &mat, const array<index_t> &indices,
    const typename matrix<T>::value_type &value
);
```

Parameters

* `mat` Target matrix.
* `indices` Target indices.
* `values` A single value or an array of values to put into `mat` at target
indices.

Returns

* None

Exceptions

* `std::invalid_argument` Thrown if `indices` and `values` have different sizes.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io/tuple.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    np::array<np::index_t> indices;
    np::array<int> values;
    std::cin >> mat >> indices >> values;
    np::put(mat, indices, values);
    std::cout << mat << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
[(0, 0), (0, 2), (1, 3), (2, 1)]
[10, 20, 30, 40]
```

```
[[ 10,  -1,  20,   3],
 [  7,  17,  11,  30],
 [  8,  40,   1, -11]]
```

`put_along_axis`

Put values into the destination matrix by matching 1d index and data slices.
Functions returning an index along an axis, like
[`argsort`](4.%20Routines.md#sorting-and-searching) and
[`argpartition`](4.%20Routines.md#sorting-and-searching), produce suitable
indices for this function.
```cpp
template <class T>
void put_along_axis(
    matrix<T> &mat, const matrix<size_t> &indices, const matrix<T> &values,
    bool rowwise
);

template <class T>
void put_along_axis(
    matrix<T> &mat, const matrix<size_t> &indices,
    const typename matrix<T>::value_type &value,
    bool rowwise
);
```

Parameters

* `mat` Destination matrix.
* `indices` A matrix-like object of `size_t` with the indices to change along
each 1d slice of `mat`.
* `values` A single value or a matrix of values to insert at those indices.
* `rowwise` If `true`, match indices along each row. Otherwise, match indices
along each column.

Exceptions

* `std::invalid_argument` Thrown if `indices` and `values` have different
number of rows and columns.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    np::matrix<size_t> indices;
    np::matrix<int> values;
    std::cin >> mat;
    std::cin >> indices >> values;
    np::put_along_axis(mat, indices, values, true);
    std::cout << "Row-wise:\n" << mat << '\n';
    std::cin >> indices >> values;
    np::put_along_axis(mat, indices, values, false);
    std::cout << "Column-wise:\n" << mat << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
[[1, 0],
 [3, 1],
 [3, 0]]
[[10, 20],
 [20, 30],
 [30, 40]]
[[1, 2, 2, 2],
 [0, 1, 1, 1]]
[[10, 20, 30, 40],
 [20, 30, 40, 50]]
```

Output

```
Row-wise:
[[20, 10,  5,  3],
 [ 7, 30, 11, 20],
 [40, -5,  1, 30]]
Column-wise:
[[20, 10,  5,  3],
 [10, 30, 40, 50],
 [40, 20, 30, 40]]
```

`extract`

Return the elements of an array that satisfy some condition. When an
[`array`](1.%20Array.md) object is given, a call such as
`np::extract(arr, condition)` is equivalent to `arr[condition]`, except that a
copy is always returned.
```cpp
template <class T>
array<T> extract(const array<T> &arr, const array<bool> &condition);
```

Parameters

* `arr` An array-like object.
* `condition` An array-like object of `bool` whose `true` entries indicate the
elements of `arr` to extract.

Returns

* A new array with the elements from `arr` where `condition` is `true`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::extract(arr, arr > 0) << '\n';
    return 0;
}
```

Input

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

Output

```
[12, 5, 3, 7, 2, 8, 17]
```

`extract`

Return the elements of a matrix that satisfy some condition. When a
[`matrix`](2.%20Matrix.md) object is given, a call such as
`np::extract(mat, condition)` is equivalent to `mat[condition]`, except that a
copy is always returned.
```cpp
template <class T>
array<T> extract(const matrix<T> &mat, const matrix<bool> &condition);
```

Parameters

* `mat` A matrix-like object.
* `condition` A matrix-like object of `bool` whose `true` entries indicate the
elements of `mat` to extract.

Returns

* A new array with the elements from `mat` where `condition` is `true`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::extract(mat, mat > 0) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
```

```
[10, 5, 3, 7, 17, 11, 6, 8, 1]
```

`extract`

Return the elements of a matrix that satisfy some condition along given axis.
```cpp
template <class T>
matrix<T> extract(
    const matrix<T> &mat, const array<bool> &condition, bool rowwise
);
```

Parameters

* `mat` A matrix-like object.
* `condition` An array-like object of `bool` whose `true` entries indicate the
elements of `mat` to extract.
* `rowwise` If `true`, extract elements along each row. Otherwise, extract
elements along each column.

Returns

* A new matrix with the elements from `mat` where `condition` is `true`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    np::array<bool> condition;
    std::cin >> mat;
    std::cin >> condition;
    std::cout << "Row-wise:\n" << np::extract(mat, condition, true) << '\n';
    std::cin >> condition;
    std::cout << "Column-wise:\n" << np::extract(mat, condition, false) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
[1, 0, 0, 1]
[1, 0, 1]
```

```
Row-wise:
[[ 10,   3],
 [  7,   6],
 [  8, -11]]
Column-wise:
[[ 10,  -1,   5,   3],
 [  8,  -5,   1, -11]]
```

`place`

Change elements of an array based on conditional and input values.
```cpp
template <class T>
void place(array<T> &arr, const array<bool> &condition, const array<T> &values);

template <class T>
void place(
    array<T> &arr, const array<bool> &condition,
    const typename array<T>::value_type &value
);
```

Parameters

* `arr` Array to put data into.
* `condition` Boolean mask array.
* `values` A single value or an array of values to place in `arr`. Only the
first `N` elements are used, where `N` is the number of `true` values in
`condition`.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    np::place(arr, arr <= 0, 1);
    std::cout << arr << '\n';
    return 0;
}
```

Input

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

Output

```
[12, 5, 1, 3, 7, 2, 8, 17, 1, 1]
```

`place`

Change elements of a matrix based on conditional and input values.
```cpp
template <class T>
void place(
    matrix<T> &mat, const matrix<bool> &condition, const array<T> &values
);

template <class T>
void place(
    matrix<T> &mat, const matrix<bool> &condition,
    const typename matrix<T>::value_type &value
);
```

Parameters

* `mat` Matrix to put data into.
* `condition` Boolean mask matrix.
* `values` A single value or an array of values to place in `mat`. Only the
first `N` elements are used, where `N` is the number of `true` values in
`condition`.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    np::place(mat, mat <= 0, 1);
    std::cout << mat << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
```

Output

```
[[10,  1,  5,  3],
 [ 7, 17, 11,  6],
 [ 8,  1,  1,  1]]
```

`putmask`

Change elements of an array based on conditional and input values. Similar to
`place`, the difference is that `place` uses the first `N` elements of
`values`, where `N` is the number of `true` values in `condition`, while
`putmask` uses the elements where `condition` is `true`.
```cpp
template <class T>
void putmask(
    array<T> &arr, const array<bool> &condition, const array<T> &values
);
```

Parameters

* `arr` Array to put data into.
* `condition` Boolean mask array.
* `values` Values to put into `arr` where `condition` is `true`.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    np::putmask(arr, arr <= 0, -arr);
    std::cout << arr << '\n';
    return 0;
}
```


Input

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

Output

```
[12, 5, 1, 3, 7, 2, 8, 17, 6, 0]
```

`putmask`

Change elements of a matrix based on conditional and input values. Similar to
`place`, the difference is that `place` uses the first `N` elements of
`values`, where `N` is the number of `true` values in `condition`, while
`putmask` uses the elements where `condition` is `true`.
```cpp
template <class T>
void putmask(
    matrix<T> &mat, const matrix<bool> &condition, const matrix<T> &values
);
```

Parameters

* `mat` Matrix to put data into.
* `condition` Boolean mask matrix.
* `values` Values to put into `mat` where `condition` is `true`.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    np::putmask(mat, mat <= 0, -mat);
    std::cout << mat << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
```

Output

```
[[10,  1,  5,  3],
 [ 7, 17, 11,  6],
 [ 8,  5,  1, 11]]
```

`select`

Return an array of elements choosen from two arrays depending on condition.
```cpp
template <class T>
array<T> select(
    const array<bool> &condition,
    const array<T> &arr1,
    const array<T> &arr2
);

template <class T>
array<T> select(
    const array<bool> &condition,
    const array<T> &arr1,
    const typename array<T>::value_type &val2
);

template <class T>
array<T> select(
    const array<bool> &condition,
    const typename array<T>::value_type &val1,
    const array<T> &arr2
);

template <class T>
array<T> select(
    const array<bool> &condition,
    const typename array<T>::value_type &val1,
    const typename array<T>::value_type &val2
);
```

Parameters

* `condition` An array-like object of `bool`, where `true`, yield `arr1`,
otherwise yield `arr2`.
* `arr1` An array-like object with the values from which to choose where
`condition` is `true`.
* `arr2` An array-like object with the values from which to choose where
`condition` is `false`.
* `val1` Value to use as `true` argument. Values are broadcasted to an
appropriate size.
* `val2` Value to use as `false` argument. Values are broadcasted to an
appropriate size.

Returns

* A light-weight object with the elements choosen from `arr1` where `condition`
is `true` and from `arr2` where `condition` is `false`. Convertible to an
[`array`](1.%20Array.md) object.

Exceptions

* `std::invalid_argument` Thrown if `condition` and array arguments have
different sizes.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << np::select(arr >= 0, arr*arr, -arr*arr) << '\n';
    return 0;
}
```

Input

```
[4, -1, 0, 5, 7, -3, 10, -2, 9, -5]
```

Output

```
[16, -1, 0, 25, 49, -9, 100, -4, 81, -25]
```

`select`

Return a matrix of elements choosen from two matrices depending on condition.
```cpp
template <class T>
matrix<T> select(
    const matrix<bool> &condition,
    const matrix<T> &mat1,
    const matrix<T> &mat2
);

template <class T>
matrix<T> select(
    const matrix<bool> &condition,
    const matrix<T> &mat1,
    const typename matrix<T>::value_type &val2
);

template <class T>
matrix<T> select(
    const matrix<bool> &condition,
    const typename matrix<T>::value_type &val1,
    const matrix<T> &mat2
);

template <class T>
matrix<T> select(
    const matrix<bool> &condition,
    const typename matrix<T>::value_type &val1,
    const typename matrix<T>::value_type &val2
);
```

Parameters

* `condition` A matrix-like object of `bool`, where `true`, yield `mat1`,
otherwise yield `mat2`.
* `mat1` A matrix-like object with the values from which to choose where
`condition` is `true`.
* `mat2` A matrix-like object with the values from which to choose where
`condition` is `false`.
* `val1` Value to use as `true` argument. Values are broadcasted to an
appropriate size.
* `val2` Value to use as `false` argument. Values are broadcasted to an
appropriate size.

Returns

* A light-weight object with the elements choosen from `mat1` where `condition`
is `true` and from `mat2` where `condition` is `false`. Convertible to a
[`matrix`](2.%20Matrix.md) object.

Exceptions

* `std::invalid_argument` Thrown if `condition` and matrix arguments have
different number of rows and columns.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << np::select(mat >= 0, mat*mat, -mat*mat) << '\n';
    return 0;
}
```

Input

```
[[4, -1, 0, 5],
 [7, -3, 10, -2],
 [9, -5, 8, 1]]
```

Output

```
[[ 16,  -1,   0,  25],
 [ 49,  -9, 100,  -4],
 [ 81, -25,  64,   1]]
```

## Functional programming

`apply`

Apply a function element-wise.
```cpp
template <class Function, class T>
array<typename std::result_of<Function(T)>::type>
apply(Function f, const array<T> &arr);
```

Parameters

* `f` The function to apply.
* `arr` An array-like object with the values where the function will be invoked.

Returns

* A light-weight object which stores the result of invoking the function on
each element. This function uses lazy-evaluation, meaning that the result of
each call is computed only at the end, when the whole expression is evaluated
or assigned to an array object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;

int square(int x) {
    return x*x;
}

double half(int x) {
    return 0.5*x;
}

struct multiply_by_x {
    int x;

    multiply_by_x(int x = 1) : x(x) {}

    int operator()(int y) const {
        return x*y;
    }
};

int main() {
    np::array<int> arr;
    std::cin >> arr;
    // Returns array<int>
    std::cout << "square:\n" << np::apply(square, arr) << '\n';
    // Returns array<double>
    std::cout << "half:\n" << np::apply(half, arr) << '\n';
    // Returns array<int>. In contrast to function pointers, functors allows to
    // contain internal state of the function.
    std::cout << "multiply_by_2:\n" << np::apply(multiply_by_x(2), arr) << '\n';
    return 0;
}
```

Input

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

Output

```
square:
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
half:
[0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5]
multiply_by_2:
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

`apply`

Apply a function element-wise.
```cpp
template <class Function, class T>
matrix<typename std::result_of<Function(T)>::type>
apply(Function f, const matrix<T> &mat);
```

Parameters

* `f` The function to apply.
* `mat` A matrix-like object with the values where the function will be invoked.

Returns

* A light-weight object which stores the result of invoking the function on
each element. This function uses lazy-evaluation, meaning that the result of
each call is computed only at the end, when the whole expression is evaluated
or assigned to a matrix object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;

int square(int x) {
    return x*x;
}

double half(int x) {
    return 0.5*x;
}

struct multiply_by_x {
    int x;

    multiply_by_x(int x = 1) : x(x) {}

    int operator()(int y) const {
        return x*y;
    }
};

int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    // Returns matrix<int>
    std::cout << "square:\n" << np::apply(square, mat) << '\n';
    // Returns matrix<double>
    std::cout << "half:\n" << np::apply(half, mat) << '\n';
    // Returns matrix<int>. In contrast to function pointers, functors allows to
    // contain internal state of the function.
    std::cout << "multiply_by_2:\n" << np::apply(multiply_by_x(2), mat) << '\n';
    return 0;
}
```

Input

```
[[0, 1, 2, 3],
 [4, 5, 6, 7],
 [8, 9, 10, 11]]
```

Output

```
square:
[[  0,   1,   4,   9],
 [ 16,  25,  36,  49],
 [ 64,  81, 100, 121]]
half:
[[  0, 0.5,   1, 1.5],
 [  2, 2.5,   3, 3.5],
 [  4, 4.5,   5, 5.5]]
multiply_by_2:
[[ 0,  2,  4,  6],
 [ 8, 10, 12, 14],
 [16, 18, 20, 22]]
```

`apply`

Apply a function element-wise.
```cpp
template <class Function, class T1, class T2>
array<typename std::result_of<Function(T1, T2)>::type>
apply(Function f, const array<T1> &arr1, const array<T2> &arr2);

template <class Function, class T1, class T2>
array<typename std::result_of<Function(T1, T2)>::type>
apply(Function f, const array<T1> &arr1, const T2 &val);

template <class Function, class T1, class T2>
array<typename std::result_of<Function(T1, T2)>::type>
apply(Function f, const T1 &val, const array<T2> &arr2);
```

Parameters

* `f` The function to apply.
* `arr1` First array-like object.
* `arr2` Second array-like object.
* `val` Value to use either as first argument or second argument. Values are
broadcasted to an appropriate size.

Returns

* A light-weight object which stores the result of invoking the function on
each element. This function uses lazy-evaluation, meaning that the result of
each call is computed only at the end, when the whole expression is evaluated
or assigned to an array object.

Exceptions

* `std::invalid_argument` Thrown if the array arguments have different sizes.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;

double true_divide(int x, int y) {
    return (double)x / (double)y;
}

int integer_pow(int x, int y) {
    if (y == 0) return 1;
    if (y % 2 == 1) return x * integer_pow(x, y - 1);
    int p = integer_pow(x, y / 2);
    return p * p;
}

struct linear_combination {
    int a, b;

    linear_combination(int a = 1, int b = 1) : a(a), b(b) {}

    int operator()(int x, int y) const {
        return a*x + b*y;
    }
};

int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    // Returns array<double>
    std::cout << "true_divide:\n" << np::apply(true_divide, arr1, arr2) << '\n';
    // Returns array<int>
    std::cout << "integer_pow:\n" << np::apply(integer_pow, arr1, arr2) << '\n';
    // Returns array<int>. In contrast to function pointers, functors allows to
    // contain internal state of the function.
    std::cout << "linear_combination:\n"
              << np::apply(linear_combination(2, 3), arr1, arr2) << '\n';
    return 0;
}
```

Input

```
[1, 1, 2, 1, 2, 3, 1, 2, 3, 4]
[1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
```

Output

```
true_divide:
[1, 0.5, 1, 0.33333333, 0.66666667, 1, 0.25, 0.5, 0.75, 1]
integer_pow:
[1, 1, 4, 1, 8, 27, 1, 16, 81, 256]
linear_combination:
[5, 8, 10, 11, 13, 15, 14, 16, 18, 20]
```

`apply`

Apply a function element-wise.
```cpp
template <class Function, class T1, class T2>
matrix<typename std::result_of<Function(T1, T2)>::type>
apply(Function f, const matrix<T1> &mat1, const matrix<T2> &mat2);

template <class Function, class T1, class T2>
matrix<typename std::result_of<Function(T1, T2)>::type>
apply(Function f, const matrix<T1> &mat1, const T2 &val);

template <class Function, class T1, class T2>
matrix<typename std::result_of<Function(T1, T2)>::type>
apply(Function f, const T1 &val, const matrix<T2> &mat2);
```

Parameters

* `f` The function to apply.
* `mat1` First matrix-like object.
* `mat2` Second matrix-like object.
* `val` Value to use either as first argument or second argument. Values are
broadcasted to an appropriate size.

Returns

* A light-weight object which stores the result of invoking the function on
each element. This function uses lazy-evaluation, meaning that the result of
each call is computed only at the end, when the whole expression is evaluated
or assigned to a matrix object.

Exceptions

* `std::invalid_argument` Thrown if the matrix arguments have different number
of rows and columns.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;

double true_divide(int x, int y) {
    return (double)x / (double)y;
}

int integer_pow(int x, int y) {
    if (y == 0) return 1;
    if (y % 2 == 1) return x * integer_pow(x, y - 1);
    int p = integer_pow(x, y / 2);
    return p * p;
}

struct linear_combination {
    int a, b;

    linear_combination(int a = 1, int b = 1) : a(a), b(b) {}

    int operator()(int x, int y) const {
        return a*x + b*y;
    }
};

int main() {
    np::matrix<int> mat1, mat2;
    std::cin >> mat1 >> mat2;
    // Returns matrix<double>
    std::cout << "true_divide:\n" << np::apply(true_divide, mat1, mat2) << '\n';
    // Returns matrix<int>
    std::cout << "integer_pow:\n" << np::apply(integer_pow, mat1, mat2) << '\n';
    // Returns matrix<int>. In contrast to function pointers, functors allows to
    // contain internal state of the function.
    std::cout << "linear_combination:\n"
              << np::apply(linear_combination(2, 3), mat1, mat2) << '\n';
    return 0;
}
```

Input

```
[[1, 1, 2, 1],
 [2, 3, 1, 2],
 [3, 4, 1, 2]]
[[1, 2, 2, 3],
 [3, 3, 4, 4],
 [4, 4, 5, 5]]
```

Output

```
true_divide:
[[         1,        0.5,          1, 0.33333333],
 [0.66666667,          1,       0.25,        0.5],
 [      0.75,          1,        0.2,        0.4]]
integer_pow:
[[  1,   1,   4,   1],
 [  8,  27,   1,  16],
 [ 81, 256,   1,  32]]
linear_combination:
[[ 5,  8, 10, 11],
 [13, 15, 14, 16],
 [18, 20, 17, 19]]
```

`apply_along_axis`

Apply a function along an axis.

```cpp
template <class Function, class T>
array<typename std::result_of<Function(
    typename matrix<T>::const_iterator, typename matrix<T>::const_iterator
)>::type>
apply_along_axis(Function f, const matrix<T> &mat, bool rowwise);
```

Parameters

* `f` The function to apply. A function that accepts two iterators as arguments
and returns a value. The iterators indicates the initial position and final
position of a range. The range used is [`first`, `last`), which includes all
the elements between `first` and `last`, including the element pointed by first
but not the element pointed by last.
* `mat` A matrix-like object with the values where the function will be invoked.
* `rowwise` If `true`, invoke the function along each row. Otherwise, invoke
the function along each column.

Returns

* A light-weight object which stores the result of invoking the function along
an axis. This function uses lazy-evaluation, meaning that the result of each
call is computed only at the end, when the whole expression is evaluated or
assigned to an array object.

Example

```cpp
#include <iostream>
#include <algorithm> // std::max_element, std::min_element
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/broadcasting.h"
#include "numcpp/io.h"
namespace np = numcpp;

struct min_max_difference {
    // Return the difference between the minimum and maximum values in the
    // range [first, last).
    template <class InputIterator>
    int operator()(InputIterator first, InputIterator last) const {
        return *std::max_element(first, last) - *std::min_element(first, last);
    }
};

int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise:\n"
              << np::apply_along_axis(min_max_difference(), mat, true) << '\n';
    std::cout << "Column-wise:\n"
              << np::apply_along_axis(min_max_difference(), mat, false) << '\n';
    return 0;
}
```

Input

```
[[10, -1, 5, 3],
 [7, 17, 11, 6],
 [8, -5, 1, -11]]
```

Output

```
Row-wise:
[11, 11, 19]
Column-wise:
[3, 22, 10, 17]
```

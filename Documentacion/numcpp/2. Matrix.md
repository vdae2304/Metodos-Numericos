# Matrix

Defined in: `numcpp/matrix.h`

## Content

- [Matrix](#matrix)
  - [Content](#content)
  - [Template parameters](#template-parameters)
  - [Member types](#member-types)
  - [Constructors](#constructors)
  - [Destructor](#destructor)
  - [Iterators](#iterators)
  - [Matrix indexing](#matrix-indexing)
  - [Advanced indexing](#advanced-indexing)
  - [Assignment operator](#assignment-operator)
  - [Compound assignment operator](#compound-assignment-operator)
  - [Operator overloading (non member functions)](#operator-overloading-non-member-functions)
  - [Public methods](#public-methods)

------

```cpp
template <class T> class matrix;
```
Matrices are contiguous two dimensional sequence containers: they hold a
specific number of elements arranged in rows and columns. Unlike a
[`matrix_view`](2.1%20Matrix%20view.md), a `matrix` is always owner of its own
data and the elements are always stored in row-major order.

Matrices are designed to easily perform mathematical operations on them. Most
mathematical operations can be applied directly to matrix objects, affecting
all its elements.

## Template parameters

* `T` Type of the elements contained in the matrix. This shall be an arithmetic
type or a class that behaves like one (such as std::complex).

## Member types

| Member type              | Definition                                                                                          |
| ------------------------ | --------------------------------------------------------------------------------------------------- |
| `value_type`             | The template parameter (`T`).                                                                       |
| `reference`              | `T&`                                                                                                |
| `const_reference`        | `const T&`                                                                                          |
| `pointer`                | `T*`                                                                                                |
| `const_pointer`          | `const T*`                                                                                          |
| `iterator`               | A [random access iterator](2.2%20Extending%20matrix%20class.md#base_matrix-iterators) to `T`.       |
| `const_iterator`         | A [random access iterator](2.2%20Extending%20matrix%20class.md#base_matrix-iterators) to `const T`. |
| `reverse_iterator`       | `std::reverse_iterator<iterator>`                                                                   |
| `const_reverse_iterator` | `std::reverse_iterator<const_iterator>`                                                             |
| `difference_type`        | A signed integral type.                                                                             |
| `size_type`              | An unsigned integral type.                                                                          |

## Constructors

Default constructor

Constructs an empty `matrix` with no elements.
```cpp
matrix();
```

Parameters

* None

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[]
```

Size constructor

Constructs a `matrix` with `m` rows and `n` columns, each element is left
uninitialized.
```cpp
matrix(size_t m, size_t n);
```

Parameters

* `m` Number of rows.
* `n` Number of columns.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(3, 4);
    std::cout << mat << '\n';
    return 0;
}
```

Possible output

```
[[-7922928,      317, -7929520,      317],
 [       0,        0,        0,        0],
 [       0,        0, 33554434,    65426]]
```

Fill constructor

Constructs a `matrix` with `m` rows and `n` columns, each element initialized
to `val`.
```cpp
matrix(size_t m, size_t n, const T &val);
```

Parameters

* `m` Number of rows.
* `n` Number of columns.
* `val` Value to which each of the elements is initialized.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Examples

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(3, 4, 0);
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[0, 0, 0, 0],
 [0, 0, 0, 0],
 [0, 0, 0, 0]]
```

Range constructor

Constructs a `matrix` with at least as many elements as the range
`[first, last)`, with each element constructed  from its corresponding element
in that range, in the same order.
```cpp
template <class InputIterator>
matrix(InputIterator first, InputIterator last, size_t n = 1);
```

Parameters

* `first` Input iterator to the initial position in a range.
* `last` Input iterator to the final position in a range. The range used is
`[first, last)`, which includes all the elements between `first` and `last`,
including the element pointed by `first` but not the element pointed by `last`.
* `n` Number of columns. The number of rows is inferred from the length of the
range. Defaults to 1.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    int ptr[] = {10, -1, 5, 3, 7, 17, 11, 6, 8, -5, 1, -11};
    np::matrix<int> mat(ptr, ptr + 12, 4);
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
```

Copy constructor

Constructs a `matrix` with a copy of each of the elements in `other`, in the
same order.
```cpp
matrix(const matrix &other);
```

Parameters

* `other` A matrix-like object of the same type.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    int ptr[] = {10, -1, 5, 3, 7, 17, 11, 6, 8, -5, 1, -11};
    np::matrix<int> mat1(ptr, ptr + 12, 4);
    np::matrix<int> mat2(mat1);
    std::cout << "mat1:\n" << mat1 << '\n';
    std::cout << "mat2:\n" << mat2 << '\n';
    return 0;
}
```

Output

```
mat1:
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
mat2:
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
```

Move constructor

Constructs a `matrix` that acquires the elements of `other`.
```cpp
matrix(matrix &&other);
```

Parameters

* `other` A `matrix` of the same type. The ownership is directly transferred
from `other`. `other` is left in an empty state.

Example

```cpp
#include <iostream>
#include <utility> // std::move
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    int ptr[] = {10, -1, 5, 3, 7, 17, 11, 6, 8, -5, 1, -11};
    np::matrix<int> mat1(ptr, ptr + 12, 4);
    np::matrix<int> mat2(std::move(mat1));
    std::cout << "mat1:\n" << mat1 << '\n';
    std::cout << "mat2:\n" << mat2 << '\n';
    return 0;
}
```

Output

```
mat1:
[]
mat2:
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
```

Nested initializer list constructor

Constructs a `matrix` with a copy of each of the elements in `il`, in the same
order.
```cpp
matrix(std::initializer_list< std::initializer_list<T> > il);
```

Parameters

* `il` An `initializer_list` object.

Returns

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat{{10, -1, 5, 3},
                        {7, 17, 11, 6},
                        {8, -5, 1, -11}};
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
```

## Destructor

```cpp
~matrix();
```

## Iterators

`matrix::begin`

Returns an iterator pointing to the first element in the `matrix`.
```cpp
iterator begin();
const_iterator begin() const;

iterator begin(bool row_major);
const_iterator begin(bool row_major) const;
```

Parameters

* `row_major` It is an optional parameter that changes the order in which
elements are iterated. If provided, the elements are iterated in row-major or
column-major order as specified by `row_major`. Otherwise, the elements are
iterated in the same order as stored in memory.

Returns

* A random access iterator to the beginning of the `matrix`. If the `matrix` is
const-qualified, the function returns a `const_iterator`. Otherwise, it returns
an `iterator`.

`matrix::end`

Returns an iterator pointing to the past-the-end element in the `matrix`. It
does not point to any element, and thus shall not be dereferenced.
```cpp
iterator end();
const_iterator end() const;

iterator end(bool row_major);
const_iterator end(bool row_major) const;
```

Parameters

* `row_major` It is an optional parameter that changes the order in which
elements are iterated. If provided, the elements are iterated in row-major or
column-major order as specified by `row_major`. Otherwise, the elements are
iterated in the same order as stored in memory.

Returns

* A random access iterator to the element past the end of the `matrix`. If the
`matrix` is const-qualified, the function returns a `const_iterator`. Otherwise,
it returns an `iterator`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(3, 4);
    // Iterate in default (row-major) order.
    int value = 0;
    np::matrix<int>::iterator it;
    for (it = mat.begin(); it != mat.end(); ++it) {
        *it = value++;
    }
    std::cout << mat << '\n';
    // Iterate in column-major order.
    value = 0;
    for (it = mat.begin(false); it != mat.end(false); ++it) {
        *it = value++;
    }
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11]]
[[ 0,  3,  6,  9],
 [ 1,  4,  7, 10],
 [ 2,  5,  8, 11]]
```

`matrix::rbegin`

Returns a reverse iterator pointing to the last element in the `matrix` (i.e.,
its reverse beginning). Reverse iterators iterate backwards.
```cpp
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;

reverse_iterator rbegin(bool row_major);
const_reverse_iterator rbegin(bool row_major) const;
```

Parameters

* `row_major` It is an optional parameter that changes the order in which
elements are iterated. If provided, the elements are iterated in row-major or
column-major order as specified by `row_major`. Otherwise, the elements are
iterated in the same order as stored in memory.

Returns

* A reverse random access iterator to the reverse beginning of the `matrix`. If
the `matrix` is const-qualified, the function returns a
`const_reverse_iterator`. Otherwise, it returns a `reverse_iterator`.

`matrix::rend`

Returns a reverse iterator pointing to the element preceding the first element
in the `matrix` (i.e., its reverse end).
```cpp
reverse_iterator rend();
const_reverse_iterator rend() const;

reverse_iterator rend(bool row_major);
const_reverse_iterator rend(bool row_major) const;
```

Parameters

* `row_major` It is an optional parameter that changes the order in which
elements are iterated. If provided, the elements are iterated in row-major or
column-major order as specified by `row_major`. Otherwise, the elements are
iterated in the same order as stored in memory.

Returns

* A reverse random access iterator to the reverse end of the `matrix`. If the
`matrix` is const-qualified, the function returns a `const_reverse_iterator`.
Otherwise, it returns a `reverse_iterator`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(3, 4);
    // Iterate in default (row-major) order.
    int value = 0;
    np::matrix<int>::reverse_iterator it;
    for (it = mat.rbegin(); it != mat.rend(); ++it) {
        *it = value++;
    }
    std::cout << mat << '\n';
    // Iterate in column-major order.
    value = 0;
    for (it = mat.rbegin(false); it != mat.rend(false); ++it) {
        *it = value++;
    }
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[11, 10,  9,  8],
 [ 7,  6,  5,  4],
 [ 3,  2,  1,  0]]
[[11,  8,  5,  2],
 [10,  7,  4,  1],
 [ 9,  6,  3,  0]]
```

`matrix::cbegin`

Returns a `const_iterator` pointing to the first element in the `matrix`.
```cpp
const_iterator cbegin() const;
const_iterator cbegin(bool row_major) const;
```

Parameters

* `row_major` It is an optional parameter that changes the order in which
elements are iterated. If provided, the elements are iterated in row-major or
column-major order as specified by `row_major`. Otherwise, the elements are
iterated in the same order as stored in memory.

Returns

* A `const_iterator` to the beginning of the `matrix`.

`matrix::cend`

Returns a `const_iterator` pointing to the past-the-end element in the `matrix`.
```cpp
const_iterator cend() const;
const_iterator cend(bool row_major) const;
```

Parameters

* `row_major` It is an optional parameter that changes the order in which
elements are iterated. If provided, the elements are iterated in row-major or
column-major order as specified by `row_major`. Otherwise, the elements are
iterated in the same order as stored in memory.

Returns

* A `const_iterator` to the element past the end of the `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat{{0, 1, 2, 3},
                        {4, 5, 6, 7},
                        {8, 9, 10, 11}};
    // Iterate in default (row-major) order.
    np::matrix<int>::const_iterator it;
    for (it = mat.cbegin(); it != mat.cend(); ++it) {
        std:: cout << *it << ' ';
    }
    std::cout << '\n';
    // Iterate in column-major order.
    for (it = mat.cbegin(false); it != mat.cend(false); ++it) {
        std::cout << *it << ' ';
    }
    std::cout << '\n';
    return 0;
}
```

Output

```
0 1 2 3 4 5 6 7 8 9 10 11
0 4 8 1 5 9 2 6 10 3 7 11
```

`matrix::crbegin`

Returns a `const_reverse_iterator` pointing to the last element in the `matrix`
(i.e., its reverse beginning).
```cpp
const_reverse_iterator crbegin() const;
const_reverse_iterator crbegin(bool row_major) const;
```

Parameters

* `row_major` It is an optional parameter that changes the order in which
elements are iterated. If provided, the elements are iterated in row-major or
column-major order as specified by `row_major`. Otherwise, the elements are
iterated in the same order as stored in memory.

Returns

* A `const_reverse_iterator` to the reverse beginning of the `matrix`.

`matrix::crend`

Returns a `const_reverse_iterator` pointing to the element preceding the first
element in the `matrix` (i.e., its reverse end).
```cpp
const_reverse_iterator crend() const;
const_reverse_iterator crend(bool row_major) const;
```

Parameters

* `row_major` It is an optional parameter that changes the order in which
elements are iterated. If provided, the elements are iterated in row-major or
column-major order as specified by `row_major`. Otherwise, the elements are
iterated in the same order as stored in memory.

Returns

* A `const_reverse_iterator` to the reverse end of the `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat{{0, 1, 2, 3},
                        {4, 5, 6, 7},
                        {8, 9, 10, 11}};
    // Iterate in default (row-major) order.
    np::matrix<int>::const_reverse_iterator it;
    for (it = mat.crbegin(); it != mat.crend(); ++it) {
        std:: cout << *it << ' ';
    }
    std::cout << '\n';
    // Iterate in column-major order.
    for (it = mat.crbegin(false); it != mat.crend(false); ++it) {
        std::cout << *it << ' ';
    }
    std::cout << '\n';
    return 0;
}
```

Output

```
11 10 9 8 7 6 5 4 3 2 1 0
11 7 3 10 6 2 9 5 1 8 4 0
```

## Matrix indexing

`matrix::operator()`

Returns a reference to the element at row `i` and column `j` in the `matrix`.
```cpp
T& operator()(size_t i, size_t j);
const T& operator()(size_t i, size_t j) const;
```
Parameters

* `i` Row position of an element in the matrix. Must be between `0` and
`rows() - 1`.
* `j` Column position of an element in the matrix. Must be between `0` and
`cols() - 1`.

Returns

* The element at the specified row and column in the `matrix`. If the `matrix`
is const-qualified, the function returns a reference to `const T`. Otherwise,
it returns a reference to `T`.

Exceptions

* `std::out_of_range` Thrown if either `i` or `j` is out of bounds.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(3, 4);
    int value = 0;
    for (unsigned i = 0; i < mat.rows(); ++i) {
        for (unsigned j = 0; j < mat.cols(); ++j) {
            mat(i, j) = value++;
        }
    }
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11]]
```

`matrix::operator[]`

Returns a reference to the element at a given row and column in the `matrix`.
```cpp
T& operator[](const index_t &index);
const T& operator[](const index_t &index) const;
```
Parameters

* `index` An `index_t` object with the row and column position of an element in
the matrix.

Returns

* The element at the specified row and column in the `matrix`. If the `matrix`
is const-qualified, the function returns a reference to `const T`. Otherwise,
it returns a reference to `T`.

Exceptions

* `std::out_of_range` Thrown if either row or column index is out of bounds

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(3, 4);
    int value = 0;
    for (unsigned i = 0; i < mat.rows(); ++i) {
        for (unsigned j = 0; j < mat.cols(); ++j) {
            mat[{i, j}] = value++;
        }
    }
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11]]
```

`matrix::rows`

Returns the number of rows in the `matrix`.
```cpp
size_t rows() const;
```

Parameters

* None

Returns

* The number of rows in the `matrix`.

`matrix::cols`

Returns the number of columns in the `matix`.
```cpp
size_t cols() const;
```

Parameters

* None

Returns

* The number of columns in the `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(2, 3);
    std::cout << "rows: " << mat.rows() << '\n';
    std::cout << "columns: " << mat.cols() << '\n';
    return 0;
}
```

Output

```
rows: 2
columns: 3
```

`matrix::size`

Returns the number of elements in the `matrix`, i.e., `rows()*cols()`.
```cpp
size_t size() const;
```

Parameters

* None

Returns

* The number of elements in the `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(2, 3);
    std::cout << "size: " << mat.size() << '\n';
    return 0;
}
```

Output

```
size: 6
```

`matrix::resize`

Resizes the `matrix` so that it contains `m` rows and `n` columns. After
resizing, if the new size is different from the total number of elements in the
`matrix`, the previous contents are lost. Otherwise, the contents are
preserved, but stored in a different order.
```cpp
void resize(size_t m, size_t n);
```

Parameters

* `m` New number of rows of the matrix.
* `n` New number of columns of the matrix.

Returns

* None

Warnings

* Invalidates all iterators, references and views to elements of the `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat = {{1}, {2}, {3}, {4}};
    std::cout << "Before resizing:\n" << mat << '\n';
    mat.resize(1, 4);
    std::cout << "After resizing (keep total size):\n" << mat << '\n';
    mat.resize(2, 3);
    std::cout << "After resizing (change total size):\n" << mat << '\n';
    return 0;
}
```

Possible output

```
Before resizing:
[[1],
 [2],
 [3],
 [4]]
After resizing (keep total size):
[[1, 2, 3, 4]]
After resizing (change total size):
[[515775248,       554, 515768656],
 [      554,         0,         0]]
```

`matrix::empty`

Returns whether the `matrix` is empty (i.e., whether its size is 0).
```cpp
bool empty() const;
```

Parameters

* None

Returns

* `true` if the `matrix` size is 0, `false` otherwise.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1(2, 3), mat2;
    if (mat1.empty()) {
        std::cout << "mat1 is empty\n";
    }
    else {
        std::cout << "mat1 is not empty\n";
    }
    if (mat2.empty()) {
        std::cout << "mat2 is empty\n";
    }
    else {
        std::cout << "mat2 is not empty\n";
    }
    return 0;
}
```

Output

```
mat1 is not empty
mat2 is empty
```

`matrix::data`

Returns a pointer to the memory array used internally by the `matrix`. Because
elements in the `matrix` are stored contiguously and in row-major order, the
pointer retrieved can be offset to access any element in the `matrix`.
```cpp
T* data();
const T* data() const;
```

Parameters
* None

Returns

* A pointer to the array used internally by the `matrix`. If the `matrix` is
const-qualified, the function returns a pointer to `const T`. Otherwise, it
returns a pointer to `T`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(3, 4);
    int *ptr = mat.data();
    for (unsigned i = 0; i < mat.size(); ++i) {
        ptr[i] = i;
    }
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11]]
```

`matrix::rowmajor`

Returns whether the elements are stored in row-major order.
```cpp
bool rowmajor() const;
```

Parameters

* None

Returns

* For `matrix` objects, always returns `true`.

`matrix::colmajor`

Returns whether the elements are stored in column-major order.
```cpp
bool colmajor() const;
```

Parameters

* None

Returns

* For `matrix` objects, always returns `false`.

## Advanced indexing

Slice indexing

Returns a [`matrix_view`](2.1%20Matrix%20view.md) object that selects the
elements specified by the slices.
```cpp
matrix_view<T> operator()(slice slc1, slice slc2);
const matrix_view<T> operator()(slice slc1, slice slc2) const;
```

Parameters

* `slc1` A [`slice`](1.0%20Slices.md) object specifying which rows of the
matrix are selected.
* `slc2` A [`slice`](1.0%20Slices.md) object specifying which columns of the
matrix are selected.

Returns

* If the `matrix` is const-qualified, the function returns a
`const matrix_view` object, which is convertible to a `matrix` object.
Otherwise, the function returns a `matrix_view` object, which has reference
semantics to the original `matrix`.

Exceptions

* `std::out_of_range` Thrown if the slices references to an element out of
bounds.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat{{10, -1, 5, 3},
                        {7, 17, 11, 6},
                        {8, -5, 1, -11}};
    np::slice slc1(3);       // Offset = 0, Size = 3, Stride = 1.
    np::slice slc2(0, 2, 2); // Offset = 0, Size = 2, Stride = 2.
    np::matrix_view<int> view = mat(slc1, slc2); // Select rows 0, 1, 2 and
                                                 // columns 0, 2.
    std::cout << view << '\n';
    view = 0;
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[10,  5],
 [ 7, 11],
 [ 8,  1]]
[[  0,  -1,   0,   3],
 [  0,  17,   0,   6],
 [  0,  -5,   0, -11]]
```

Row indexing

Returns an [`array_view`](1.1%20Array%20view.md) object that selects the
elements specified by the slice along the given row.
```cpp
array_view<T> operator()(size_t i, slice slc);
const array_view<T> operator()(size_t i, slice slc) const;
```

Parameters

* `i` Row position in the matrix. Must be between `0` and `rows() - 1`.
* `slc` A [`slice`](1.0%20Slices.md) object specifying which columns of the
matrix are selected.

Returns

* If the `matrix` is const-qualified, the function returns a `const array_view`
object, which is convertible to an `array` object. Otherwise, the function
returns an `array_view` object, which has reference semantics to the original
`matrix`.

Exceptions

* `std::out_of_range` Thrown if the slice references to an element out of
bounds.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat{{10, -1, 5, 3},
                        {7, 17, 11, 6},
                        {8, -5, 1, -11}};
    np::array_view<int> view = mat(1, np::slice(4)); // Select second row.
    std::cout << view << '\n';
    view = 0;
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[7, 17, 11, 6]
[[ 10,  -1,   5,   3],
 [  0,   0,   0,   0],
 [  8,  -5,   1, -11]]
```

Column indexing

Returns an [`array_view`](1.1%20Array%20view.md) object that selects the
elements specified by the slice along the given column.
```cpp
array_view<T> operator()(slice slc, size_t j);
const array_view<T> operator()(slice slc, size_t j) const;
```

Parameters

* `slc` A [`slice`](1.0%20Slices.md) object specifying which rows of the matrix
are selected.
* `j` Column position in the matrix. Must be between `0` and `cols() - 1`.

Returns

* If the `matrix` is const-qualified, the function returns a `const array_view`
object, which is convertible to an `array` object. Otherwise, the function
returns an `array_view` object, which has reference semantics to the original
`matrix`.

Exceptions

* `std::out_of_range` Thrown if the slice references to an element out of
bounds.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat{{10, -1, 5, 3},
                        {7, 17, 11, 6},
                        {8, -5, 1, -11}};
    np::array_view<int> view = mat(np::slice(3), 2); // Select third column.
    std::cout << view << '\n';
    view = 0;
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[5, 11, 1]
[[ 10,  -1,   0,   3],
 [  7,  17,   0,   6],
 [  8,  -5,   0, -11]]
```

Coordinate array indexing

Returns an [`index_view`](1.2%20Index%20view.md) object that selects the
elements specified by the array of indices.
```cpp
index_view<T> operator[](const array<index_t> &index);
array<T> operator[](const array<index_t> &index) const;
```

Parameters

* `index` An `array<index_t>` object with its elements identifying which
elements of the matrix are selected.

Returns

* If the `matrix` is const-qualified, the function returns a new `array` object
with a copy of the selection. Otherwise, the function returns an `index_view`
object, which has reference semantics to the original matrix.

Exceptions

* `std::out_of_range` Thrown if the array of indices references to an element
out of bounds.
* `std::bad_alloc` If the function needs to allocate storage and fails, it may
throw an exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat{{10, -1, 5, 3},
                        {7, 17, 11, 6},
                        {8, -5, 1, -11}};
    np::array<np::index_t> index{{0, 0}, {0, 2}, {1, 3}, {2, 1}};
    // Select positions (0, 0), (0, 2), (1, 3), (2, 1).
    np::index_view<int> view = mat[index];
    std::cout << view << '\n';
    view = 0;
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[10, 5, 6, -5]
[[  0,  -1,   0,   3],
 [  7,  17,  11,   0],
 [  8,   0,   1, -11]]
```

Boolean matrix indexing

Returns an [`index_view`](1.2%20Index%20view.md) object that selects the
elements specified by the boolean mask.
```cpp
index_view<T> operator[](const matrix<bool> &mask);
array<T> operator[](const matrix<bool> &mask) const;
```

Parameters

* `mask` A `matrix<bool>` object with its elements identifying whether each
element of the matrix is selected or not.

Returns

* If the `matrix` is const-qualified, the function returns a new `array` object
with a copy of the selection. Otherwise, the function returns an `index_view`
object, which has reference semantics to the original `matrix`.

Exceptions

* `std::bad_alloc` If the function needs to allocate storage and fails, it may
throw an exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat{{10, -1, 5, 3},
                        {7, 17, 11, 6},
                        {8, -5, 1, -11}};
    np::matrix<bool> mask{{1, 0, 1, 0},
                          {0, 0, 0, 1},
                          {0, 1, 0, 0}};
    // Select positions (0, 0), (0, 2), (1, 3), (2, 1).
    np::index_view<int> view = mat[mask];
    std::cout << view << '\n';
    view = 0;
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[10, 5, 6, -5]
[[  0,  -1,   0,   3],
 [  7,  17,  11,   0],
 [  8,   0,   1, -11]]
```

## Assignment operator

Copy assignment

Assigns to each element the value of the corresponding element in `other` after
resizing the object (if necessary).
```cpp
matrix& operator=(const matrix &other);
```

Parameters

* `other` A matrix-like object of the same type.

Returns

* `*this`.

Exceptions

* `std::bad_alloc` If the function needs to allocate storage and fails, it may
throw an exception.

Warnings

* When the number of rows and columns do not mach, invalidates all iterators,
references and views to elements of the `matrix`. Otherwise, valid iterators,
references and views keep their validity.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1{{10, -1, 5, 3},
                         {7, 17, 11, 6},
                         {8, -5, 1, -11}};
    np::matrix<int> mat2;
    std::cout << "Before:\n";
    std::cout << "mat1:\n" << mat1 << '\n';
    std::cout << "mat2:\n" << mat2 << '\n';
    mat2 = mat1;
    std::cout << "After:\n";
    std::cout << "mat1:\n" << mat1 << '\n';
    std::cout << "mat2:\n" << mat2 << '\n';
    return 0;
}
```

Output

```
Before:
mat1:
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
mat2:
[]
After:
mat1:
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
mat2:
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
```

Fill assignment

Assigns `val` to every element. The size of the `matrix` is preserved.
```cpp
matrix& operator=(const T &val);
```

Parameters

* `val` Value assigned to all the elements in the matrix.

Returns

* `*this`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat(3, 4);
    std::cout << "Before:\n" << mat << '\n';
    mat = 0;
    std::cout << "After:\n" << mat << '\n';
    return 0;
}
```

Possible output

```
Before:
[[-1207493872,         535, -1207500464,         535],
 [          0,           0,           0,           0],
 [          0,           0,    33554434,       53690]]
After:
[[0, 0, 0, 0],
 [0, 0, 0, 0],
 [0, 0, 0, 0]]
```

Move assignment

Acquires the contents of `other`, leaving `other` in an empty state.
```cpp
matrix& operator=(matrix &&other);
```

Parameters

* `other` A `matrix` of the same type.

Returns

* `*this`.

Warnings

* All iterators, references and views to elements of the matrix are invalidated.

Example

```cpp
#include <iostream>
#include <utility> // std::move
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1{{10, -1, 5, 3},
                         {7, 17, 11, 6},
                         {8, -5, 1, -11}};
    np::matrix<int> mat2;
    std::cout << "Before:\n";
    std::cout << "mat1:\n" << mat1 << '\n';
    std::cout << "mat2:\n" << mat2 << '\n';
    mat2 = std::move(mat1);
    std::cout << "After:\n";
    std::cout << "mat1:\n" << mat1 << '\n';
    std::cout << "mat2:\n" << mat2 << '\n';
    return 0;
}
```

Output

```
Before:
mat1:
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
mat2:
[]
After:
mat1:
[]
mat2:
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
```

Nested initializer list assignment

Assigns to each element the value of the corresponding element in `il` after
resizing the object (if necessary).
```cpp
matrix& operator=(std::initializer_list< std::initializer_list<T> > il);
```

Parameters

* `il` An `initializer_list` object.

Returns

* `*this`.

Exceptions

* `std::bad_alloc` If the function needs to allocate storage and fails, it may
throw an exception.

Warnings

* When the number of rows and columns do not mach, invalidates all iterators,
references and views to elements of the `matrix`. Otherwise, valid iterators,
references and views keep their validity.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cout << "Before:\n" << mat << '\n';
    mat = {{10, -1, 5, 3},
           {7, 17, 11, 6},
           {8, -5, 1, -11}};
    std::cout << "After:\n"<< mat << '\n';
    return 0;
}
```

Output

```
Before:
[]
After:
[[ 10,  -1,   5,   3],
 [  7,  17,  11,   6],
 [  8,  -5,   1, -11]]
```

## Compound assignment operator

Assigns to `*this` the result of performing the respective operation on all the
elements in the `matrix`.

When the right-hand side argument is a `matrix` object, the operation is
performed between the corresponding elements in each object (the first element
of the left one with the right one, the second with the second, and so on...)

When the right-hand side argument is a value, the operation is applied to all
the elements in the `matrix` against that value.
```cpp
matrix& operator+=(const matrix &rhs);
matrix& operator-=(const matrix &rhs);
matrix& operator*=(const matrix &rhs);
matrix& operator/=(const matrix &rhs);
matrix& operator%=(const matrix &rhs);
matrix& operator&=(const matrix &rhs);
matrix& operator|=(const matrix &rhs);
matrix& operator^=(const matrix &rhs);
matrix& operator<<=(const matrix &rhs);
matrix& operator>>=(const matrix &rhs);

matrix& operator+=(const T &val);
matrix& operator-=(const T &val);
matrix& operator*=(const T &val);
matrix& operator/=(const T &val);
matrix& operator%=(const T &val);
matrix& operator&=(const T &val);
matrix& operator|=(const T &val);
matrix& operator^=(const T &val);
matrix& operator<<=(const T &val);
matrix& operator>>=(const T &val);
```

Parameters

* `rhs` Right-hand side matrix-like object.
* `val` Value to use as right-hand operand.

Returns

* `*this`.

Exceptions

* `std::invalid_argument` Thrown if the right-hand side argument is a `matrix`
object with different number of rows and columns to `*this`.

## Operator overloading (non member functions)

Each of this functions performs their respective operation on all the elements
in the `matrix`.

When both the left-hand side and right-hand side arguments are `matrix`
objects, the operation is performed between the corresponding elements in each
object (the first element of the left one with the right one, the second with
the second, and so on...)

When one of the arguments is a value, the operation is applied to all the
elements in the `matrix` against that value.
```cpp
/// Unary operators.
template <class T>
matrix<T> operator+(const matrix<T> &mat);
template <class T>
matrix<T> operator-(const matrix<T> &mat);
template <class T>
matrix<T> operator~(const matrix<T> &mat);
template <class T>
matrix<bool> operator!(const matrix<T> &mat);

/// Arithmetic operators.
template <class T>
matrix<T> operator+(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<T> operator+(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator+(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<T> operator-(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<T> operator-(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator-(const typename matrix<T>::value_type &val, const matrix_view<T> &rhs);

template <class T>
matrix<T> operator*(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<T> operator*(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator*(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<T> operator/(const matrix<T> &lhs, const matmatrixrix_view<T> &rhs);
template <class T>
matrix<T> operator/(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator/(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<T> operator%(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<T> operator%(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator%(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

/// Bitwise operators.
template <class T>
matrix<T> operator&(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<T> operator&(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator&(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<T> operator|(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<T> operator|(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator|(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<T> operator^(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<T> operator^(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator^(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<T> operator<<(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<T> operator<<(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator<<(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<T> operator>>(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<T> operator>>(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<T> operator>>(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

/// Logical operators.
template <class T>
matrix<bool> operator&&(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<bool> operator&&(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<bool> operator&&(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<bool> operator||(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<bool> operator||(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<bool> operator||(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

/// Relational operators.
template <class T>
matrix<bool> operator==(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<bool> operator==(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<bool> operator==(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<bool> operator!=(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<bool> operator!=(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<bool> operator!=(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<bool> operator<(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<bool> operator<(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<bool> operator<(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<bool> operator>(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<bool> operator>(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<bool> operator>(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<bool> operator<=(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<bool> operator<=(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<bool> operator<=(const typename matrix<T>::value_type &val, const matrix<T> &rhs);

template <class T>
matrix<bool> operator>=(const matrix<T> &lhs, const matrix<T> &rhs);
template <class T>
matrix<bool> operator>=(const matrix<T> &lhs, const typename matrix<T>::value_type &val);
template <class T>
matrix<bool> operator>=(const typename matrix<T>::value_type &val, const matrix<T> &rhs);
```

Parameters

* `lhs` Left-hand side matrix-like object.
* `rhs` Right-hand side matrix-like object.
* `val` Value to use either as left-hand or right-hand operand.

Returns

* A light-weight object which stores the result of performing the operation on
each element. Each of these operators uses lazy-evaluation, meaning that the
result of each operation is computed only at the end, when the whole expression
is evaluated or assigned to a `matrix` object.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments
are `matrix` objects with different number of rows and columns.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> x;
    std::cin >> x;
    // Almost equivalent to (notice that there are no temporary matrices):
    // np::matrix<int> y(x.rows(), x.cols());
    // for (unsigned i = 0; i < x.rows(); ++i) {
    //     for (unsigned j = 0; j < x.cols(); ++j) {
    //         y(i, j) = x(i, j)*x(i, j) - 3*x(i, j) + 2;
    //     }
    // }
    // std::cout << y << '\n';
    std::cout << x*x - 3*x + 2 << '\n';
    return 0;
}
```

Input
```
[[-3, -2, -1],
 [0, 1, 2],
 [3, 4, 5]]
```

Output

```
[[20, 12,  6],
 [ 2,  0,  0],
 [ 2,  6, 12]]
```

## Public methods

`matrix::apply`

Assigns to each element the result of applying a function to the corresponding
elements in `*this`.
```cpp
void apply(T f(T));
void apply(T f(const T&));
template <class Function>
void apply(Function f);
```

Parameters

* `f` A function that accepts one element of type `T` as argument, and returns
a value convertible to `T`.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;

int square(int x) {
    return x*x;
}

int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    mat.apply(square);
    std::cout << mat << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
[[  1,  81,   0,  25],
 [100,   4,  49,  64],
 [  0, 144,   9,   1]]
```

`matrix::argmax`

Return the indices of the maximum value in the `matrix`.
```cpp
index_t argmax() const;
```

Parameters

* None

Returns

* The indices of the maximum value in the `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    np::index_t index = mat.argmax();
    std::cout << "(" << index.first << ", " << index.second  << ")\n";
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
(2, 1)
```

`matrix::argmax`

Return the index of the maximum value in the `matrix` along the specified axis.
```cpp
array<size_t> argmax(bool rowwise) const;
```

Parameters

* `rowwise` If `true`, return the index of the maximum value along each row.
Otherwise, return the index of the maximum value along each column.

Returns
* A light-weight object with the index of the maximum value along an axis.
Convertible to an [`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << mat.argmax(true) << '\n';
    std::cout << "Column-wise: " << mat.argmax(false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [3, 0, 1]
Column-wise: [1, 2, 1, 1]
```

`matrix::argmin`

Return the indices of the minimum value in the `matrix`.
```cpp
index_t argmin() const;
```

Parameters

* None

Returns

* The indices of the minimum value in the `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    np::index_t index = mat.argmin();
    std::cout << "(" << index.first << ", " << index.second  << ")\n";
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
(0, 1)
```

`matrix::argmin`

Return the index of the minimum value in the `matrix` along the specified axis.
```cpp
array<size_t> argmin(bool rowwise) const;
```

Parameters

* `rowwise` If `true`, return the index of the minimum value along each row.
Otherwise, return the index of the minimum value along each column.

Returns

* A light-weight object with the index of the minimum value along an axis.
Convertible to an [`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << mat.argmin(true) << '\n';
    std::cout << "Column-wise: " << mat.argmin(false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [1, 1, 3]
Column-wise: [2, 0, 0, 2]
```

`matrix::astype`

Cast each element to a specified type.
```cpp
template <class U>
matrix<U> astype() const;
```

Parameters

* None

Returns

* A light-weight object with the elements in the `matrix` casted  to the
specified type. Convertible to a `matrix` object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << mat.astype<int>() << '\n';
    return 0;
}
```

Input

```
[[0.1, -1, 6.33, 0.5],
 [-2.3, 9.8, 7, 1.2],
 [0, -5.3, 2.1, 12.7]]
```

Output

```
[[ 0, -1,  6,  0],
 [-2,  9,  7,  1],
 [ 0, -5,  2, 12]]
```

`matrix::clamp`

Clamp the values in the `matrix`. Given an interval `[a_min, a_max]`, values
smaller than `a_min` become `a_min`, and values larger than `a_max` become
`a_max`. If `T` is a complex type, then real and imaginary parts are clamped
separately.
```cpp
void clamp(const T &a_min, const T &a_max);
```

Parameters

* `a_min` The lower boundary to clamp.
* `a_max` The upper boundary to clamp.

Returns

* None

Notes

* The behavior is undefined if `a_min` is greater than `a_max`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    int a_min, a_max;
    std::cin >> mat >> a_min >> a_max;
    mat.clamp(a_min, a_max);
    std::cout << mat << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
1 10
```

Output

```
[[ 1,  1,  1,  5],
 [10,  1,  7,  8],
 [ 1, 10,  3,  1]]
```

`matrix::conj`

Return the complex conjugate, element-wise.
```cpp
matrix conj() const;
```

Parameters

* None

Returns

* A light-weight object with the complex conjugate of each element in the
`matrix`. Convertible to a `matrix` object.

Example

```cpp
#include <iostream>
#include <complex>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<std::complex<double>> mat;
    std::cin >> mat;
    std::cout << mat.conj() << '\n';
    return 0;
}
```

Input

```
[[(1,0), (-9,3), (0,-1), (5,2)],
 [(10,-3), (-2,5), (7,-10), (8,8)],
 [(0,0), (12,10), (3,11), (-1,7)]]
```

Output

```
[[  (1,-0),  (-9,-3),    (0,1),   (5,-2)],
 [  (10,3),  (-2,-5),   (7,10),   (8,-8)],
 [  (0,-0), (12,-10),  (3,-11),  (-1,-7)]]
```

`matrix::diagonal`

Return a view of the diagonal of `*this`.
```cpp
array_view<T> diagonal(ptrdiff_t offset = 0);
const array_view<T> diagonal(ptrdiff_t offset = 0) const;
```

Parameters

* `offset` Offset of the diagonal from the main diagonal. A positive value
refers to an upper diagonal and a negative value refers to a lower diagonal.
Defaults to 0 (main diagonal).

Returns

* If the `matrix` is const-qualified, the function returns a `const array_view`
object, which is convertible to an [`array`](1.%20Array.md) object. Otherwise,
the function returns an [`array_view`](1.1%20Array%20view.md) object, which has
reference semantics to the original `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Main diagonal: " << mat.diagonal() << '\n';
    std::cout << "Subdiagonal: " << mat.diagonal(-1) << '\n';
    std::cout << "Superdiagonal: " << mat.diagonal(1) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1],
 [-3, 5, 0, -7]]
```

Output

```
Main diagonal: [1, -2, 3, -7]
Subdiagonal: [10, 12, 0]
Superdiagonal: [-9, 7, -1]
```

`matrix::dot`

Return the matrix multiplication of a matrix and a column-vector.
```cpp
array<T> dot(const array<T> &rhs) const;
```

Parameters

* `rhs` Right-hand side array-like object.

Returns

* The matrix-vector multiplication with `rhs`.

Exceptions

* `std::invalid_argument` Thrown if the number of columns of `*this` and the
size of `rhs` do not match.
* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    np::array<int> arr;
    std::cin >> mat >> arr;
    std::cout << mat.dot(arr) << '\n';
    return 0;
}
```


Input

```
[[7, 1, 8, -1, -9],
 [3, 2, 5, 12, 8],
 [10, 0, 3, -2, 7]]
[1, 5, 2, 0, 1]
```

Output

```
[19, 31, 23]
```

`matrix::dot`

Return the matrix multiplication of two matrices.
```cpp
matrix dot(const matrix &rhs) const;
```

Parameters

* `rhs` Right-hand side matrix-like object.

Returns

* The matrix multiplication with `rhs`.

Exceptions

* `std::invalid_argument` Thrown if the number of columns of `*this` and the
number of rows of `rhs` do not match.
* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1, mat2;
    std::cin >> mat1 >> mat2;
    std::cout << mat1.dot(mat2) << '\n';
    return 0;
}
```

Input

```
[[7, 1, 8, -1],
 [3, 2, 5, 12],
 [10, 0, 3, -2]]
[[1, 7],
 [5, -1],
 [2, 2],
 [0, 8]]
```

Output

```
[[ 28,  56],
 [ 23, 125],
 [ 16,  60]]
```

`matrix::flatten`

Return a view of the `matrix` collapsed into an array.
```cpp
array_view<T> flatten();
const array_view<T> flatten() const;
```

Parameters

* None

Returns

* If the matrix is const-qualified, the function returns a `const array_view`
object, which is convertible to an [`array`](1.%20Array.md) object. Otherwise,
the function returns an [`array_view`](1.1%20Array%20view.md) object, which has
reference semantics to the original `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << mat.flatten() << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
[1, -9, 0, 5, 10, -2, 7, 8, 0, 12, 3, -1]
```

`matrix::imag`

Return or set the imaginary part, element-wise.
```cpp
/// Complex types.
matrix<typename T::value_type> imag() const;
void imag(const typename T::value_type &val);
void imag(const matrix<typename T::value_type> &mat);

/// Non-complex types.
matrix<T> imag() const;
```

Parameters

* `val` Value to set the imaginary part to.
* `mat` A matrix-like object with the values to set the imaginary part to.

Returns

* A light-weight object with the imaginary part of each element in the
`matrix`. Convertible to a `matrix` object.

Example

```cpp
#include <iostream>
#include <complex>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<std::complex<double>> mat;
    std::cin >> mat;
    std::cout << mat.imag() << '\n';
    mat.imag(0);
    std::cout << mat << '\n';
    return 0;
}
```

Input

```
[[(1,0), (-9,3), (0,-1), (5,2)],
 [(10,-3), (-2,5), (7,-10), (8,8)],
 [(0,0), (12,10), (3,11), (-1,7)]]
```

Output

```
[[  0,   3,  -1,   2],
 [ -3,   5, -10,   8],
 [  0,  10,  11,   7]]
[[ (1,0), (-9,0),  (0,0),  (5,0)],
 [(10,0), (-2,0),  (7,0),  (8,0)],
 [ (0,0), (12,0),  (3,0), (-1,0)]]
```

`matrix::max`

Return the maximum value contained in the `matrix`.
```cpp
T max() const;
```

Parameters

* None

Returns

* The maximum value in the `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << mat.max() << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
12
```

`matrix::max`

Return the maximum value contained in the `matrix` along the specified axis.
```cpp
array<T> max(bool rowwise) const;
```

Parameters

* `rowwise` If `true`, return the maximum value along each row. Otherwise,
return the maximum value along each column.

Returns

* A light-weight object with the maximum value along an axis. Convertible to an
[`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << mat.max(true) << '\n';
    std::cout << "Column-wise: " << mat.max(false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [5, 10, 12]
Column-wise: [10, 12, 7, 8]
```

`matrix::mean`

Return the average of the `matrix` elements.
```cpp
T mean() const;
```

Parameters

* None

Returns

* The average of the `matrix` elements.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << mat.mean() << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
2.83333
```

`matrix::mean`

Return the average of the `matrix` elements along the specified axis.
```cpp
array<T> mean(bool rowwise) const;
```

Parameters

* `rowwise` If `true`, return the average of the elements along each row.
Otherwise, return the average of the elements along each column.

Returns

* A light-weight object with the average along an axis. Convertible to an
[`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << mat.mean(true) << '\n';
    std::cout << "Column-wise: " << mat.mean(false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [-0.75, 5.75, 3.5]
Column-wise: [3.6666667, 0.33333333, 3.3333333, 4]
```

`matrix::min`

Return the minimum value contained in the `matrix`.
```cpp
T min() const;
```

Parameters

* None

Returns

* The minimum value in the `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << mat.min() << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
-9
```

`matrix::min`

Return the minimum value contained in the `matrix` along the specified axis.
```cpp
array<T> min(bool rowwise) const;
```

Parameters

* `rowwise` If `true`, return the minimum value along each row. Otherwise,
return the minimum value along each column.

Returns

* A light-weight object with the minimum value along an axis. Convertible to an
[`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << mat.min(true) << '\n';
    std::cout << "Column-wise: " << mat.min(false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [-9, -2, -1]
Column-wise: [0, -9, 0, -1]
```

`matrix::partition`

Partition a `matrix` in-place.
```cpp
void partition(size_t kth, bool rowwise);
template <class Compare>
void partition(size_t kth, bool rowwise, Compare comp);
```

Parameters

* `kth` Element index to partition by. The element at the `kth` position is the
element that would be in that position in the sorted array. The other elements
are left without any specific order, except that none of the elements preceding
`kth` are greater than it, and none of the elements following it are less.
* `rowwise` If `true`, partition the elements along each row. Otherwise,
partition the elements along each column.
* `comp` Custom comparator. A binary function that accepts two elements of type
`T` as arguments, and returns a value convertible to `bool`. The value returned
indicates whether the element passed as first argument is considered to go
before the second.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    int kth;
    std::cin >> mat >> kth;
    mat.partition(kth, true);
    std::cout << "Row-wise:\n" << mat << '\n';
    mat.partition(kth, false);
    std::cout << "Column-wise:\n" << mat << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
 1
```

Output

```
Row-wise:
[[-9,  0,  1,  5],
 [-2,  7, 10,  8],
 [-1,  0,  3, 12]]
Column-wise:
[[-9,  0,  1,  5],
 [-2,  0,  3,  8],
 [-1,  7, 10, 12]]
```

`matrix::prod`

Return the product of the `matrix` elements.
```cpp
T prod() const;
```

Parameters

* None

Returns

* The product of the `matrix` elements.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << mat.prod() << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
479001600
```

`matrix::prod`

Return the product of the `matrix` elements along the specified axis.
```cpp
array<T> prod(bool rowwise) const;
```

Parameters

* `rowwise` If `true`, return the product of the elements along each row.
Otherwise, return the product of the elements along each column.

Returns

* A light-weight object with the product along an axis. Convertible to an
[`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << mat.prod(true) << '\n';
    std::cout << "Column-wise: " << mat.prod(false) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
Row-wise: [24, 1680, 11880]
Column-wise: [45, 120, 231, 384]
```

`matrix::real`

Return or set the real part, element-wise.
```cpp
/// Complex types.
matrix<typename T::value_type> real() const;
void real(const typename T::value_type &val);
void real(const matrix<typename T::value_type> &mat);

/// Non-complex types.
matrix<T> real() const;
```

Parameters

* `val` Value to set the real part to.
* `mat` A matrix-like object with the values to set the real part to.

Returns

* A light-weight object with the real part of each element in the `matrix`.
Convertible to a `matrix` object.

Example

```cpp
#include <iostream>
#include <complex>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<std::complex<double>> mat;
    std::cin >> mat;
    std::cout << mat.real() << '\n';
    mat.real(0);
    std::cout << mat << '\n';
    return 0;
}
```

Input

```
[[(1,0), (-9,3), (0,-1), (5,2)],
 [(10,-3), (-2,5), (7,-10), (8,8)],
 [(0,0), (12,10), (3,11), (-1,7)]]
```

Output

```
[[ 1, -9,  0,  5],
 [10, -2,  7,  8],
 [ 0, 12,  3, -1]]
[[  (0,0),   (0,3),  (0,-1),   (0,2)],
 [ (0,-3),   (0,5), (0,-10),   (0,8)],
 [  (0,0),  (0,10),  (0,11),   (0,7)]]
```

`matrix::reverse`

Reverse the order of the elements in-place along an axis.
```cpp
void reverse(bool rowwise);
```

Parameters

* `rowwise` If `true`, reverse the elements along each row. Otherwise, reverse
the elements along each column.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    mat.reverse(true);
    std::cout << "Row-wise:\n" << mat << '\n';
    mat.reverse(false);
    std::cout << "Column-wise:\n" << mat << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise:
[[ 5,  0, -9,  1],
 [ 8,  7, -2, 10],
 [-1,  3, 12,  0]]
Column-wise:
[[-1,  3, 12,  0],
 [ 8,  7, -2, 10],
 [ 5,  0, -9,  1]]
```

`matrix::sort`

Sort a `matrix` in-place along an axis.
```cpp
void sort(bool rowwise);
template <class Compare>
void sort(bool rowwise, Compare comp, bool stable = false);
```

Parameters

* `rowwise` If `true`, sort the elements along each row. Otherwise, sort the
elements along each column.
* `comp` Custom comparator. A binary function that accepts two elements of type
`T` as arguments, and returns a value convertible to `bool`. The value
returned indicates whether the element passed as first argument is considered
to go before the second.
* `stable` If `true`, preserve the relative order of the elements with
equivalent values. Otherwise, equivalent elements are not guaranteed to keep
their original relative order.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    mat.sort(true);
    std::cout << "Row-wise:\n" << mat << '\n';
    mat.sort(false);
    std::cout << "Column-wise:\n" << mat << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise:
[[-9,  0,  1,  5],
 [-2,  7,  8, 10],
 [-1,  0,  3, 12]]
Column-wise:
[[-9,  0,  1,  5],
 [-2,  0,  3, 10],
 [-1,  7,  8, 12]]
```

`matrix::stddev`

Return the standard deviation of the `matrix` elements.
```cpp
T stddev(size_t ddof = 0) const;
```

Parameters

* `ddof` Delta degrees of freedom. (See
[`numcpp::stddev`](4.%20Routines.md#basic-statistics) for full documentation.)

Returns

* The standard deviation of the `matrix` elements.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << mat.stddev() << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
5.63964
```

`matrix::stddev`

Return the standard deviation of the `matrix` elements along the specified axis.
```cpp
array<T> stddev(size_t ddof, bool rowwise) const;
```

Parameters

* `ddof` Delta degrees of freedom. (See
[`numcpp::stddev`](4.%20Routines.md#basic-statistics) for full documentation.)
* `rowwise` If `true`, return the standard deviation of the elements along each
row. Otherwise, return the standard deviation of the elements along each
column.

Returns

* A light-weight object with the standard deviation along an axis. Convertible
to an [`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << mat.stddev(0, true) << '\n';
    std::cout << "Column-wise: " << mat.stddev(0, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise: [5.1173724, 4.6029882, 5.1234754]
Column-wise: [4.4969125, 8.7305339, 2.8674418, 3.7416574]
```

`matrix::sum`

Return the sum of the `matrix` elements.
```cpp
T sum() const;
```

Parameters

* None

Returns

* The sum of the `matrix` elements.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << mat.sum() << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
78
```

`matrix::sum`

Return the sum of the `matrix` elements along the specified axis.
```cpp
array<T> sum(bool rowwise) const;
```

Parameters

* `rowwise` If `true`, return the sum of the elements along each row.
Otherwise, return the sum of the elements along each column.

Returns

* A light-weight object with the sum along an axis. Convertible to an
[`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    std::cout << "Row-wise: " << mat.sum(true) << '\n';
    std::cout << "Column-wise: " << mat.sum(false) << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
Row-wise: [10, 26, 42]
Column-wise: [15, 18, 21, 24]
```

`matrix::swap`

Exchanges the content of the `matrix` by the content of `other`. Implemented to
run in constant time.
```cpp
void swap(matrix &other);
```

Parameters

* `other` A `matrix` of the same type.

Returns

* All valid iterators, references and views of both `*this` and `other` keep
their validity, and are now referring to the same elements they referred to
before the call, but in the other `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat1, mat2;
    std::cin >> mat1 >> mat2;
    std::cout << "Before swap:\n";
    std::cout << "mat1:\n" << mat1 << '\n';
    std::cout << "mat2:\n" << mat2 << '\n';
    mat1.swap(mat2);
    std::cout << "After swap:\n";
    std::cout << "mat1:\n" << mat1 << '\n';
    std::cout << "mat2:\n" << mat2 << '\n';
    return 0;
}
```

Input

```
[[1, 5, 2],
 [0, 1, 8]]
[[0, 7],
 [-1, 2],
 [8, 3]]
```

Output

```
Before swap:
mat1:
[[1, 5, 2],
 [0, 1, 8]]
mat2:
[[ 0,  7],
 [-1,  2],
 [ 8,  3]]
After swap:
mat1:
[[ 0,  7],
 [-1,  2],
 [ 8,  3]]
mat2:
[[1, 5, 2],
 [0, 1, 8]]
```

`matrix::t`

Return a view of the matrix transposed.
```cpp
matrix_view<T> t();
const matrix_view<T> t() const;
```

Parameters

* None

Returns

* If the `matrix` is const-qualified, the function returns a
`const matrix_view` object, which is convertible to a `matrix` object.
Otherwise, the function returns a [`matrix_view`](2.1%20Matrix%20view.md)
object, which has reference semantics to the original `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<int> mat;
    std::cin >> mat;
    np::matrix_view<int> transpose = mat.t();
    std::cout << transpose << '\n';
    return 0;
}
```

Input

```
[[1, 2, 3, 4],
 [5, 6, 7, 8],
 [9, 10, 11, 12]]
```

Output

```
[[ 1,  5,  9],
 [ 2,  6, 10],
 [ 3,  7, 11],
 [ 4,  8, 12]]
```

`matrix::var`

Return the variance of the `matrix` elements.
```cpp
T var(size_t ddof = 0) const;
```

Parameters

* `ddof` Delta degrees of freedom. (See
[`numcpp::var`](4.%20Routines.md#basic-statistics) for full documentation.)

Returns

* The variance of the `matrix` elements.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Biased: " << mat.var() << '\n';
    std::cout << "Unbiased: " << mat.var(1) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Biased: 31.8056
Unbiased: 34.697
```

`matrix::var`

Return the variance of the `matrix` elements along the specified axis.
```cpp
array<T> var(size_t ddof, bool rowwise) const;
```

Parameters

* `ddof` Delta degrees of freedom. (See
[`numcpp::var`](4.%20Routines.md#basic-statistics) for full documentation.)
* `rowwise` If `true`, return the variance of the elements along each row.
Otherwise, return the variance of the elements along each column.

Returns

* A light-weight object with the variance along an axis. Convertible to an
[`array`](1.%20Array.md) object.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::matrix<double> mat;
    std::cin >> mat;
    std::cout << "Row-wise (biased): " << mat.var(0, true) << '\n';
    std::cout << "Row-wise (unbiased): " << mat.var(1, true) << '\n';
    std::cout << "Column-wise (biased): " << mat.var(0, false) << '\n';
    std::cout << "Column-wise (unbiased): " << mat.var(1, false) << '\n';
    return 0;
}
```

Input

```
[[1, -9, 0, 5],
 [10, -2, 7, 8],
 [0, 12, 3, -1]]
```

Output

```
Row-wise (biased): [26.1875, 21.1875, 26.25]
Row-wise (unbiased): [34.916667, 28.25, 35]
Column-wise (biased): [20.222222, 76.222222, 8.2222222, 14]
Column-wise (unbiased): [30.333333, 114.33333, 12.333333, 21]
```

`matrix::view`

Return a view of the `matrix` with the same data.
```cpp
matrix_view<T> view();
```

Parameters

* None

Returns

* A [`matrix_view`](2.1%20Matrix%20view.md) object, which has reference
semantics to the original `matrix`.

Example

```cpp
#include <iostream>
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;

void fill_view(np::matrix_view<int> view) {
    int value = 0;
    for (unsigned i = 0; i < view.rows(); ++i) {
        for (unsigned j = 0; j < view.cols(); ++j) {
            view(i, j) = value++;;
        }
    }
}

int main() {
    np::matrix<int> mat(3, 4);
    fill_view(mat.view());
    std::cout << mat << '\n';
    return 0;
}
```

Output

```
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11]]
```
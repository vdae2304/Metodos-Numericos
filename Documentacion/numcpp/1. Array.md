# Array

Defined in: `numcpp/array.h`

## Content

- [Array](#array)
  - [Content](#content)
  - [Template parameters](#template-parameters)
  - [Member types](#member-types)
  - [Constructors](#constructors)
  - [Destructor](#destructor)
  - [Iterators](#iterators)
  - [Array indexing](#array-indexing)
  - [Advanced indexing](#advanced-indexing)
  - [Assignment operator](#assignment-operator)
  - [Compound assignment operator](#compound-assignment-operator)
  - [Operator overloading (non member functions)](#operator-overloading-non-member-functions)
  - [Public methods](#public-methods)

-----

```cpp
template <class T> class array;
```
Arrays are contiguous sequence containers: they hold a specific number of
elements ordered in a strict linear sequence. Unlike an
[`array_view`](1.1%20Array%20view.md), an `array` is always owner of its own
data.

Arrays are designed to easily perform mathematical operations on them. Most
mathematical operations can be applied directly to array objects, affecting all
its elements.

## Template parameters

* `T` Type of the elements contained in the array. This shall be an arithmetic
type or a class that behaves like one (such as `std::complex`).

## Member types

| Member type              | Definition                                                                                        |
| ------------------------ | ------------------------------------------------------------------------------------------------- |
| `value_type`             | The template parameter (`T`).                                                                     |
| `reference`              | `T&`                                                                                              |
| `const_reference`        | `const T&`                                                                                        |
| `pointer`                | `T*`                                                                                              |
| `const_pointer`          | `const T*`                                                                                        |
| `iterator`               | A [random access iterator](1.3%20Extending%20array%20class.md##base_array-iterators) to `T`.      |
| `const_iterator`         | A [random access iterator](1.3%20Extending%20array%20class.md#base_array-iterators) to `const T`. |
| `reverse_iterator`       | `std::reverse_iterator<iterator>`                                                                 |
| `const_reverse_iterator` | `std::reverse_iterator<const_iterator>`                                                           |
| `difference_type`        | A signed integral type.                                                                           |
| `size_type`              | An unsigned integral type.                                                                        |

## Constructors

Default constructor

Constructs an empty `array` with no elements.
```cpp
array();
```

Parameters

* None

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cout << arr << '\n';
    return 0;
}

```

Output

```
[]
```

Size constructor

Constructs an `array` with `n` elements, each element is left uninitialized.
```cpp
array(size_t n);
```

Parameters

* `n` Length of array.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr(10);
    std::cout << arr << '\n';
    return 0;
}

```

Possible output

```
[-520217840, 303, -520224432, 303, 0, 0, 0, 0, 0, 0]
```

Fill constructor

Constructs an `array` with `n` elements, each element initialized to `val`.
```cpp
array(size_t n, const T &val);
```

Parameters

* `n` Length of array.
* `val` Value to which each of the elements is initialized.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr(10, 0);
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

Range constructor

Constructs an `array` with as many elements as the range `[first, last)`, with
each element constructed from its corresponding element in that range, in the
same order.
```cpp
template <class InputIterator>
array(InputIterator first, InputIterator last);
```

Parameters

* `first` Input iterator to the initial position in a range.
* `last` Input iterator to the final position in a range. The range used is
`[first, last)`, which includes all the elements between `first` and `last`,
including the element pointed by `first` but not the element pointed by `last`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    int ptr[] = {12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    np::array<int> arr(ptr, ptr + 10);
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

Copy constructor

Constructs an `array` with a copy of each of the elements in `other`, in the
same order.
```cpp
array(const array &other);
```

Parameters

* `other` An array-like object of the same type.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    int ptr[] = {12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    np::array<int> arr1(ptr, ptr + 10);
    np::array<int> arr2(arr1);
    std::cout << "arr1: " << arr1 << '\n';
    std::cout << "arr2: " << arr2 << '\n';
    return 0;
}
```

Output

```
arr1: [12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
arr2: [12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

Move constructor

Constructs an `array` that acquires the elements of `other`.
```cpp
array(array &&other);
```

Parameters

* `other` An `array` of the same type. The ownership is directly transferred
from `other`. `other` is left in an empty state.

Example

```cpp
#include <iostream>
#include <utility> // std::move
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    int ptr[] = {12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    np::array<int> arr1(ptr, ptr + 10);
    np::array<int> arr2(std::move(arr1));
    std::cout << "arr1: " << arr1 << '\n';
    std::cout << "arr2: " << arr2 << '\n';
    return 0;
}
```

Example

```cpp
arr1: []
arr2: [12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

Initializer list constructor

Constructs an `array` with a copy of each of the elements in `il`, in the same
order.
```cpp
array(std::initializer_list<T> il);
```

Parameters

* `il` An `initializer_list` object.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr{12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

## Destructor

```cpp
~array();
```

## Iterators

`array::begin`

Returns an iterator pointing to the first element in the `array`.
```cpp
iterator begin();
const_iterator begin() const;
```

Parameters

* None

Returns

* A random access iterator to the beginning of the `array`. If the `array` is
const-qualified, the function returns a `const_iterator`. Otherwise, it returns
an `iterator`.

`array::end`

Returns an iterator pointing to the past-the-end element in the array. It does
not point to any element, and thus shall not be dereferenced.
```cpp
iterator end();
const_iterator end() const;
```

Parameters

* None

Returns

* A random access iterator to the element past the end of the `array`. If the
`array` is const-qualified, the function returns a `const_iterator`. Otherwise,
it returns an `iterator`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr(10);
    int value = 0;
    np::array<int>::iterator it;
    for (it = arr.begin(); it != arr.end(); ++it) {
        *it = value++;
    }
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

`array::rbegin`

Returns a reverse iterator pointing to the last element in the `array` (i.e.,
its reverse beginning). Reverse iterators iterate backwards.
```cpp
reverse_iterator rbegin();
const_reverse_iterator rbegin() const;
```

Parameters

* None

Returns

* A reverse random access iterator to the reverse beginning of the `array`. If
the `array` is const-qualified, the function returns a `const_reverse_iterator`.
Otherwise, it returns a `reverse_iterator`.

`array::rend`

Returns a reverse iterator pointing to the element preceding the first element
in the `array` (i.e., its reverse end).
```cpp
reverse_iterator rend();
const_reverse_iterator rend() const;
```

Parameters

* None

Returns

* A reverse random access iterator to the reverse end of the `array`. If
the `array` is const-qualified, the function returns a `const_reverse_iterator`.
Otherwise, it returns a `reverse_iterator`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr(10);
    int value = 0;
    np::array<int>::reverse_iterator it;
    for (it = arr.rbegin(); it != arr.rend(); ++it) {
        *it = value++;
    }
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```

`array::cbegin`

Returns a `const_iterator` pointing to the first element in the `array`.
```cpp
const_iterator cbegin() const;
```

Parameters

* None

Returns

* A `const_iterator` to the beginning of the `array`.

`array::cend`

Returns a `const_iterator` pointing to the past-the-end element in the `array`.
```cpp
const_iterator cend() const;
```

Parameters

* None

Returns

* A `const_iterator` to the element past the end of the `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
namespace np = numcpp;
int main() {
    np::array<int> arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    np::array<int>::const_iterator it;
    for (it = arr.cbegin(); it != arr.cend(); ++it) {
        std::cout << *it << ' ';
    }
    std::cout << '\n';
    return 0;
}
```

Output

```
0 1 2 3 4 5 6 7 8 9
```

`array::crbegin`

Returns a `const_reverse_iterator` pointing to the last element in the `array`
(i.e., its reverse beginning).
```cpp
const_reverse_iterator crbegin() const;
```

Parameters

* None

Returns

* A `const_reverse_iterator` to the reverse beginning of the `array`.

`array::crend`

Returns a `const_reverse_iterator` pointing to the element preceding the first
element in the `array` (i.e., its reverse end).
```cpp
const_reverse_iterator crend() const;
```

Parameters

* None

Returns
* A `const_reverse_iterator` to the reverse end of the `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
namespace np = numcpp;
int main() {
    np::array<int> arr{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    np::array<int>::const_reverse_iterator it;
    for (it = arr.crbegin(); it != arr.crend(); ++it) {
        std::cout << *it << ' ';
    }
    std::cout << '\n';
    return 0;
}
```

Output

```
9 8 7 6 5 4 3 2 1 0
```

## Array indexing

`array::operator[]`

Returns a reference to the element at position `i` in the `array`.
```cpp
T& operator[](size_t i);
const T& operator[](size_t i) const;
```

Parameters

* `i` Position of an element in the array. Must be between `0` and `size() - 1`.

Returns

* The element at the specified position in the `array`. If the `array` is
const-qualified, the function returns a reference to `const T`. Otherwise, it
returns a reference to `T`.

Exceptions

* `std::out_of_range` Thrown if `i` is out of bounds.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr(10);
    for (unsigned i = 0; i < arr.size(); ++i) {
        arr[i] = i;
    }
    std::cout << arr << '\n';
    return 0;
}

```

Output

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

`array::size`

Returns the number of elements in the `array`.
```cpp
size_t size() const;
```

Parameters

* None

Returns

* The number of elements in the `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
namespace np = numcpp;
int main() {
    np::array<int> arr(5);
    std::cout << "size: " << arr.size() << '\n';
    return 0;
}
```

Output

```
size: 5
```

`array::resize`

Resizes the `array` so that it contains `n` elements. After resizing, the
previous contents are lost.
```cpp
void resize(size_t n);
```

Parameters

* `n` New size of the array.

Returns

* None

Warnings

* Invalidates all iterators, references and views to elements of the `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
namespace np = numcpp;
int main() {
    np::array<int> arr(5);
    std::cout << "Before resizing: " << arr.size() << '\n';
    arr.resize(10);
    std::cout << "After resizing: " << arr.size() << '\n';
    return 0;
}
```

Output

```
Before resizing: 5
After resizing: 10
```

`array::empty`

Returns whether the `array` is empty (i.e., whether its size is 0).
```cpp
bool empty() const;
```

Parameters

* None

Returns

* `true` if the array size is 0, `false` otherwise.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1(5), arr2;
    if (arr1.empty()) {
        std::cout << "arr1 is empty\n";
    }
    else {
        std::cout << "arr1 is not empty\n";
    }
    if (arr2.empty()) {
        std::cout << "arr2 is empty\n";
    }
    else {
        std::cout << "arr2 is not empty\n";
    }
    return 0;
}
```

Output

```
arr1 is not empty
arr2 is empty
```

`array::data`

Returns a pointer to the memory array used internally by the `array`. Because
elements in the `array` are stored contiguously, the pointer retrieved can be
offset to access any element in the `array`.
```cpp
T* data();
const T* data() const;
```

Parameters

* None

Returns

* A pointer to the array used internally by the `array`. If the `array` is
const-qualified, the function returns a pointer to `const T`. Otherwise, it
returns a pointer to `T`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr(10);
    int *ptr = arr.data();
    for (unsigned i = 0; i < arr.size(); ++i) {
        ptr[i] = i;
    }
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

## Advanced indexing

Slice indexing

Returns an [`array_view`](1.1%20Array%20view.md) object that selects the
elements specified by the slice.
```cpp
array_view<T> operator[](slice slc);
const array_view<T> operator[](slice slc) const;
```

Parameters

* `slc` A [`slice`](1.0%20Slices.md) object specifying which elements of the
array are selected.

Returns

* If the `array` is const-qualified, the function returns a `const array_view`
object, which is convertible to an `array` object. Otherwise, the function
returns an `array_view` object, which has reference semantics to the original
`array`.

Exceptions

* `std::out_of_range` Thrown if the slice references to an element out of
bounds.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr{12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    np::slice slc(1, 4, 2);              // Offset = 1, Size = 4, Stride = 2.
    np::array_view<int> view = arr[slc]; // Select indices 1, 3, 5, 7.
    std::cout << view << '\n';
    view *= 2;
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[5, 3, 2, 17]
[12, 10, -1, 6, 7, 4, 8, 34, -6, 0]
```

Integer array indexing

Returns an [`index_view`](1.2%20Index%20view.md) object that selects the
elements specified by the array of indices.
```cpp
index_view<T> operator[](const array<size_t> &index);
array operator[](const array<size_t> &index) const;
```

Parameters

* `index` An `array<size_t>` object with its elements identifying which
elements of the array are selected.

Returns

* If the `array` is const-qualified, the function returns a new `array` object
with a copy of the selection. Otherwise, the function returns an `index_view`
object, which has reference semantics to the original array.

Exceptions

* `std::out_of_range` Thrown if the array of indices references to an element
out of bounds.
* `std::bad_alloc` If the function needs to allocate storage and fails, it may
throw an exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr{12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    np::array<size_t> index{1, 2, 3, 5, 8};
    np::index_view<int> view = arr[index]; // Select indices 1, 2, 3, 5, 8.
    std::cout << view << '\n';
    view *= 2;
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[5, -1, 3, 2, -6]
[12, 10, -2, 6, 7, 4, 8, 17, -12, 0]
```

Boolean array indexing

Returns an [`index_view`](1.2%20Index%20view.md) object that selects the
elements specified by the boolean mask.
```cpp
index_view<T> operator[](const array<bool> &mask);
array operator[](const array<bool> &mask) const;
```

Parameters

* `mask` An `array<bool>` object with its elements identifying whether each
element of the array is selected or not.

Returns

* If the `array` is const-qualified, the function returns a new `array` object
with a copy of the selection. Otherwise, the function returns an `index_view`
object, which has reference semantics to the original `array`.

Exceptions

* `std::bad_alloc` If the function needs to allocate storage and fails, it may
throw an exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr{12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    np::array<bool> mask{0, 1, 1, 1, 0, 1, 0, 0, 1, 0};
    np::index_view<int> view = arr[mask]; // Select indices 1, 2, 3, 5, 8.
    std::cout << view << '\n';
    view *= 2;
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[5, -1, 3, 2, -6]
[12, 10, -2, 6, 7, 4, 8, 17, -12, 0]
```

## Assignment operator

Copy assignment

Assigns to each element the value of the corresponding element in `other` after
resizing the object (if necessary).
```cpp
array& operator=(const array &other);
```

Parameters

* `other` An array-like object of the same type.

Returns

* `*this`.

Exceptions

* `std::bad_alloc` If the function needs to allocate storage and fails, it may
throw an exception.

Warnings

* When the sizes do not mach, invalidates all iterators, references and views
to elements of the `array`. Otherwise, valid iterators, references and views
keep their validity.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1{12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    np::array<int> arr2;
    std::cout << "Before:\n";
    std::cout << "arr1: " << arr1 << '\n';
    std::cout << "arr2: " << arr2 << '\n';
    arr2 = arr1;
    std::cout << "After:\n";
    std::cout << "arr1: " << arr1 << '\n';
    std::cout << "arr2: " << arr2 << '\n';
    return 0;
}
```

Output

```
Before:
arr1: [12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
arr2: []
After:
arr1: [12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
arr2: [12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

Fill assignment

Assigns `val` to every element. The size of the `array` is preserved.
```cpp
array& operator=(const T &val);
```

Parameters

* `val` Value assigned to all the elements in the array.

Returns

* `*this`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr(10);
    std::cout << "Before: " << arr << '\n';
    arr = 0;
    std::cout << "After: " << arr << '\n';
    return 0;
}
```

Possible output

```
Before: [-1973478640, 500, -1973485232, 500, 0, 0, 0, 0, 0, 0]
After: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
```

Move assignment

Acquires the contents of `other`, leaving `other` in an empty state.
```cpp
array& operator=(array &&other);
```

Parameters

* `other` An `array` of the same type.

Returns

* `*this`.

Warnings

* All iterators, references and views to elements of the array are invalidated.

Example

```cpp
#include <iostream>
#include <utility> // std::move
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1{12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    np::array<int> arr2;
    std::cout << "Before:\n";
    std::cout << "arr1: " << arr1 << '\n';
    std::cout << "arr2: " << arr2 << '\n';
    arr2 = std::move(arr1);
    std::cout << "After:\n";
    std::cout << "arr1: " << arr1 << '\n';
    std::cout << "arr2: " << arr2 << '\n';
    return 0;
}
```

Output

```
Before:
arr1: [12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
arr2: []
After:
arr1: []
arr2: [12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

Initializer list assignment

Assigns to each element the value of the corresponding element in `il` after
resizing the object (if necessary).
```cpp
array& operator=(std::initializer_list<T> il);
```

Parameters

* `il` An `initializer_list` object.

Returns

* `*this`.

Exceptions

* `std::bad_alloc` If the function needs to allocate storage and fails, it may
throw an exception.

Warnings

* When the sizes do not mach, invalidates all iterators, references and views
to elements of the `array`. Otherwise, valid iterators, references and views
keep their validity.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cout << "Before: " << arr << '\n';
    arr = {12, 5, -1, 3, 7, 2, 8, 17, -6, 0};
    std::cout << "After: " << arr << '\n';
    return 0;
}
```

Output

```
Before: []
After: [12, 5, -1, 3, 7, 2, 8, 17, -6, 0]
```

## Compound assignment operator

Assigns to `*this` the result of performing the respective operation on all the
elements in the `array`.

When the right-hand side argument is an `array` object, the operation is
performed between the corresponding elements in each object (the first element
of the left one with the right one, the second with the second, and so on...)

When the right-hand side argument is a value, the operation is applied to all
the elements in the `array` against that value.
```cpp
array& operator+=(const array &rhs);
array& operator-=(const array &rhs);
array& operator*=(const array &rhs);
array& operator/=(const array &rhs);
array& operator%=(const array &rhs);
array& operator&=(const array &rhs);
array& operator|=(const array &rhs);
array& operator^=(const array &rhs);
array& operator<<=(const array &rhs);
array& operator>>=(const array &rhs);

array& operator+=(const T &val);
array& operator-=(const T &val);
array& operator*=(const T &val);
array& operator/=(const T &val);
array& operator%=(const T &val);
array& operator&=(const T &val);
array& operator|=(const T &val);
array& operator^=(const T &val);
array& operator<<=(const T &val);
array& operator>>=(const T &val);
```

Parameters

* `rhs` Right-hand side array-like object.
* `val` Value to use as right-hand operand.

Returns

* `*this`.

Exceptions

* `std::invalid_argument` Thrown if the right-hand side argument is an `array`
object with different size to `*this`.

## Operator overloading (non member functions)

Each of this functions performs their respective operation on all the elements
in the `array`.

When both the left-hand side and right-hand side arguments are `array` objects,
the operation is performed between the corresponding elements in each object
(the first element of the left one with the right one, the second with the
second, and so on...)

When one of the arguments is a value, the operation is applied to all the
elements in the `array` against that value.
```cpp
/// Unary operators.
template <class T>
array<T> operator+(const array<T> &arr);
template <class T>
array<T> operator-(const array<T> &arr);
template <class T>
array<T> operator~(const array<T> &arr);
template <class T>
array<bool> operator!(const array<T> &arr);

/// Arithmetic operators.
template <class T>
array<T> operator+(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator+(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator+(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<T> operator-(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator-(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator-(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<T> operator*(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator*(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator*(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<T> operator/(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator/(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator/(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<T> operator%(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator%(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator%(const typename array<T>::value_type &val, const array<T> &rhs);

/// Bitwise operators.
template <class T>
array<T> operator&(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator&(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator&(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<T> operator|(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator|(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator|(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<T> operator^(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator^(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator^(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<T> operator<<(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator<<(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator<<(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<T> operator>>(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<T> operator>>(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<T> operator>>(const typename array<T>::value_type &val, const array<T> &rhs);

/// Logical operators.
template <class T>
array<bool> operator&&(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<bool> operator&&(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<bool> operator&&(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<bool> operator||(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<bool> operator||(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<bool> operator||(const typename array<T>::value_type &val, const array<T> &rhs);

/// Relational operators.
template <class T>
array<bool> operator==(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<bool> operator==(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<bool> operator==(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<bool> operator!=(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<bool> operator!=(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<bool> operator!=(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<bool> operator<(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<bool> operator<(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<bool> operator<(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<bool> operator>(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<bool> operator>(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<bool> operator>(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<bool> operator<=(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<bool> operator<=(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<bool> operator<=(const typename array<T>::value_type &val, const array<T> &rhs);

template <class T>
array<bool> operator>=(const array<T> &lhs, const array<T> &rhs);
template <class T>
array<bool> operator>=(const array<T> &lhs, const typename array<T>::value_type &val);
template <class T>
array<bool> operator>=(const typename array<T>::value_type &val, const array<T> &rhs);
```

Parameters

* `lhs` Left-hand side array-like object.
* `rhs` Right-hand side array-like object.
* `val` Value to use either as left-hand or right-hand operand.

Returns

* A light-weight object which stores the result of performing the operation on
each element. Each of these operators uses lazy-evaluation, meaning that the
result of each operation is computed only at the end, when the whole expression
is evaluated or assigned to an `array` object.

Exceptions

* `std::invalid_argument` Thrown if the left-hand and right-hand side arguments
are `array` objects with different sizes.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> x;
    std::cin >> x;
    // Almost equivalent to (notice that there are no temporary arrays):
    // np::array<int> y(x.size());
    // for (unsigned i = 0; i < x.size(); ++i) {
    //     y[i] = x[i]*x[i] - 3*x[i] + 2;
    // }
    // std::cout << y << '\n';
    std::cout << x*x - 3*x + 2 << '\n';
    return 0;
}
```

Input

```
[-2, -1, 0, 1, 2, 3, 4, 5]
```

Output

```
[12, 6, 2, 0, 0, 2, 6, 12]
```

## Public methods

`array::apply`

Assigns to each element the result of applying a function to the corresponding
elements in `*this`.
```cpp
void apply(T f(T));
void apply(T f(const T&));
template <class Function>
void apply(Function f);
```

Parameters

* `f` A function that accepts one element of type `T` as argument, and returns
a value convertible to `T`.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;

int square(int x) {
    return x*x;
}

int main() {
    np::array<int> arr;
    std::cin >> arr;
    arr.apply(square);
    std::cout << arr << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
[1, 81, 25, 100, 4, 49, 64, 144, 0, 9]
```

`array::argmax`

Return the index of the maximum value in the `array`.
```cpp
size_t argmax() const;
```

Parameters

* None

Returns

* The index of the maximum value in the `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << arr.argmax() << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
7
```

`array::argmin`

Return the index of the minimum value in the `array`.

```cpp
size_t argmin() const;
```

Parameters
* None

Returns

* The index of the minimum value in the `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << arr.argmin() << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
1
```

`array::argpartition`

Return the indices that would partition the `array`.
```cpp
array<size_t> argpartition(size_t kth) const;
template <class Compare>
array<size_t> argpartition(size_t kth, Compare comp) const;
```

Parameters

* `kth` Element index to partition by. The element at the `kth` position is the
element that would be in that position in the sorted array. The other elements
are left without any specific order, except that none of the elements preceding
`kth` are greater than it, and none of the elements following it are less.
* `comp` Custom comparator. A binary function that accepts two elements of type
`T` as arguments, and returns a value convertible to `bool`. The value returned
indicates whether the element passed as first argument is considered to go
before the second.

Returns

* An `array` of indices that partitions the `array`. If `a` is an `array`, then
`a[a.argpartition()]` yields a partitioned `a`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;

bool sort_by_abs(int a, int b) {
    return std::abs(a) < std::abs(b);
}

int main() {
    np::array<int> arr;
    int kth;
    std::cin >> arr >> kth;

    std::cout << "Default partition:\n";
    np::array<size_t> index = arr.argpartition(kth);
    std::cout << "index: " << index << '\n';
    std::cout << "arr[index]: " << arr[index] << '\n';

    std::cout << "Partition by absolute value:\n";
    index = arr.argpartition(kth, sort_by_abs);
    std::cout << "index: " << index << '\n';
    std::cout << "arr[index]: " << arr[index] << '\n';

    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
4
```

Output

```
Default partition:
index: [4, 1, 8, 0, 9, 5, 6, 7, 3, 2]
arr[index]: [-2, -9, -1, 1, 3, 7, 9, 12, 10, 5]
Partition by absolute value:
index: [8, 0, 9, 4, 2, 5, 6, 7, 3, 1]
arr[index]: [-1, 1, 3, -2, 5, 7, 9, 12, 10, -9]
```

`array::argsort`

Return the indices that would sort the `array`.

```cpp
array<size_t> argsort() const;
template <class Compare>
array<size_t> argsort(Compare comp, bool stable = false);
```

Parameters

* `comp` Custom comparator. A binary function that accepts two elements of type
`T` as arguments, and returns a value convertible to `bool`. The value returned
indicates whether the element passed as first argument is considered to go
before the second.
* `stable` If `true`, preserve the relative order of the elements with
equivalent values. Otherwise, equivalent elements are not guaranteed to keep
their original relative order.

Returns

* An `array` of indices that sort the `array`. If `a` is an `array`, then
`a[a.argsort()]` yields a sorted `a`.

Exceptions

* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;

bool sort_by_abs(int a, int b) {
    return std::abs(a) < std::abs(b);
}

int main() {
    np::array<int> arr;
    std::cin >> arr;

    std::cout << "Default sort:\n";
    np::array<size_t> index = arr.argsort();
    std::cout << "index: " << index << '\n';
    std::cout << "arr[index]: " << arr[index] << '\n';

    std::cout << "Sort by absolute value:\n";
    index = arr.argsort(sort_by_abs, true);
    std::cout << "index: " << index << '\n';
    std::cout << "arr[index]: " << arr[index] << '\n';

    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
Default sort:
index: [1, 4, 8, 0, 9, 2, 5, 6, 3, 7]
arr[index]: [-9, -2, -1, 1, 3, 5, 7, 9, 10, 12]
Sort by absolute value:
index: [0, 8, 4, 9, 2, 5, 1, 6, 3, 7]
arr[index]: [1, -1, -2, 3, 5, 7, -9, 9, 10, 12]
```

`array::astype`

Cast each element to a specified type.
```cpp
template <class U>
array<U> astype() const;
```

Parameters

* None

Returns

* A light-weight object with the elements in the `array` casted to the
specified type. Convertible to an `array` object.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << arr.astype<int>() << '\n';
    return 0;
}
```

Input

```
[0.1, -1., 6.33, 0.5, 9.8, 7., 1.2, 0., -5.3, 2.1]
```

Output

```
[0, -1, 6, 0, 9, 7, 1, 0, -5, 2]
```

`array::clamp`

Clamp the values in the `array`. Given an interval `[a_min, a_max]`, values
smaller than `a_min` become `a_min`, and values larger than `a_max` become
`a_max`. If `T` is a complex type, then real and imaginary parts are clamped
separately.
```cpp
void clamp(const T &a_min, const T &a_max);
```

Parameters

* `a_min` The lower boundary to clamp.
* `a_max` The upper boundary to clamp.

Returns

* None

Notes

* The behavior is undefined if `a_min` is greater than `a_max`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    int a_min, a_max;
    std::cin >> arr >> a_min >> a_max;
    arr.clamp(a_min, a_max);
    std::cout << arr << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
1 10
```

Output

```
[1, 1, 5, 10, 1, 7, 8, 10, 1, 3]
```

`array::conj`

Return the complex conjugate, element-wise.
```cpp
array conj() const;
```

Parameters

* None

Returns

* A light-weight object with the complex conjugate of each element in the
`array`. Convertible to an `array` object.

Example

```cpp
#include <iostream>
#include <complex>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<std::complex<double>> arr;
    std::cin >> arr;
    std::cout << arr.conj() << '\n';
    return 0;
}
```

Input

```
[(1,7), (-9,8), (5,12), (10,0), (-2,3)]
```

Output

```
[(1,-7), (-9,-8), (5,-12), (10,-0), (-2,-3)]
```

`array::dot`

Return the inner product of two arrays (without complex conjugation).
```cpp
T dot(const array &rhs) const;
```

Parameters

* `rhs` Right-hand side array-like object.

Returns

* The inner product with `rhs`.

Exceptions

* `std::invalid_argument` Thrown if the sizes do not match.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << arr1.dot(arr2) << '\n';
    return 0;
}
```

Input

```
[1, 5, 2, 0, 1]
[7, -1, 2, 8, 3]
```

Output

```
9
```

`array::dot`

Return the matrix multiplication of a row-vector and a matrix.
```cpp
array dot(const matrix<T> &rhs) const;
```

Parameters

* `rhs` Right-hand side matrix-like object.

Returns

* The vector-matrix multiplication with `rhs`.

Exceptions

* `std::invalid_argument` Thrown if the size of `*this` and the number of rows
of `rhs` do not match.
* `std::bad_alloc` If the function fails to allocate storage it may throw an
exception.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/matrix.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    np::matrix<int> mat;
    std::cin >> arr >> mat;
    std::cout << arr.dot(mat) << '\n';
    return 0;
}
```

Input

```
[1, 5, 2, 0, 1]
[[7, 1, 8],
 [-1, -9, 3],
 [2, 5, 12],
 [8, 10, 0],
 [3, -2, 7]]
```

Output

```
[9, -36, 54]
```

`array::imag`

Return or set the imaginary part, element-wise.
```cpp
/// Complex types.
array<typename T::value_type> imag() const;
void imag(const array<typename T::value_type> &arr);

/// Non-complex types.
array<T> imag() const;
```

Parameters

* `arr` An array-like object with the values to set the imaginary part to.

Returns

* A light-weight object with the imaginary part of each element in the `array`.
Convertible to an `array` object.

Example

```cpp
#include <iostream>
#include <complex>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<std::complex<double>> arr;
    np::array<double> imag;
    std::cin >> arr;
    std::cout << arr.imag() << '\n';
    std::cin >> imag;
    arr.imag(imag);
    std::cout << arr << '\n';
    return 0;
}
```

Input

```
[(1,7), (-9,8), (5,12), (10,0), (-2,3)]
[0, 0, 0, 0, 0]
```

Output

```
[7, 8, 12, 0, 3]
[(1,0), (-9,0), (5,0), (10,0), (-2,0)]
```

`array::max`

Return the maximum value contained in the `array`.
```cpp
T max() const;
```

Parameters

* None

Returns

* The maximum value in the `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << arr.max() << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
12
```

`array::mean`

Return the average of the `array` elements.
```cpp
T mean() const;
```

Parameters

* None

Returns

* The average of the `array` elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << arr.mean() << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
3.5
```

`array::min`

Return the minimum value contained in the `array`.
```cpp
T min() const;
```

Parameters

* None

Returns

* The minimum value in the `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << arr.min() << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
-9
```

`array::partition`

Partition an `array` in-place.
```cpp
void partition(size_t kth);
template <class Compare>
void partition(size_t kth, Compare comp);
```

Parameters

* `kth` Element index to partition by. The element at the `kth` position is the
element that would be in that position in the sorted array. The other elements
are left without any specific order, except that none of the elements preceding
`kth` are greater than it, and none of the elements following it are less.
* `comp` Custom comparator. A binary function that accepts two elements of type
`T` as arguments, and returns a value convertible to `bool`. The value returned
indicates whether the element passed as first argument is considered to go
before the second.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;

bool sort_by_abs(int a, int b) {
    return std::abs(a) < std::abs(b);
}

int main() {
    np::array<int> arr;
    int kth;
    std::cin >> arr >> kth;
    arr.partition(kth, sort_by_abs);
    std::cout << "Partition by absolute value: " << arr << '\n';
    arr.partition(kth);
    std::cout << "Default partition: " << arr << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
4
```

Output

```
Partition by absolute value: [-1, 1, 3, -2, 5, 7, 9, 12, 10, -9]
Default partition: [1, -1, -9, -2, 3, 5, 7, 12, 10, 9]
```

`array::prod`

Return the product of the `array` elements.
```cpp
T prod() const;
```

Parameters

* None

Returns

* The product of the `array` elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << arr.prod() << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Output

```
3628800
```

`array::real`

Return or set the real part, element-wise.
```cpp
/// Complex types.
array<typename T::value_type> real() const;
void real(const array<typename T::value_type> &arr);

/// Non-complex types.
array<T> real() const;
```

Parameters

* `arr` An array-like object with the values to set the real part to.

Returns

* A light-weight object with the real part of each element in the `array`.
Convertible to an `array` object.

Example

```cpp
#include <iostream>
#include <complex>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<std::complex<double>> arr;
    np::array<double> real;
    std::cin >> arr;
    std::cout << arr.real() << '\n';
    std::cin >> real;
    arr.real(real);
    std::cout << arr << '\n';
    return 0;
}
```

Input

```
[(1,7), (-9,8), (5,12), (10,0), (-2,3)]
[0, 0, 0, 0, 0]
```

Output

```
[1, -9, 5, 10, -2]
[(0,7), (0,8), (0,12), (0,0), (0,3)]
```

`array::reverse`

Reverse the order of the elements in-place.
```cpp
void reverse();
```

Parameters

* None

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    arr.reverse();
    std::cout << arr << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
[3, -1, 12, 9, 7, -2, 10, 5, -9, 1]
```

`array::sort`

Sort an `array` in-place.
```cpp
void sort();
template <class Compare>
void sort(Compare comp, bool stable = false);
```

Parameters

* `comp` Custom comparator. A binary function that accepts two elements of type
`T` as arguments, and returns a value convertible to `bool`. The value returned
indicates whether the element passed as first argument is considered to go
before the second.
* `stable` If `true`, preserve the relative order of the elements with
equivalent values. Otherwise, equivalent elements are not guaranteed to keep
their original relative order.

Returns

* None

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;

bool sort_by_abs(int a, int b) {
    return std::abs(a) < std::abs(b);
}

int main() {
    np::array<int> arr;
    std::cin >> arr;
    arr.sort(sort_by_abs, true);
    std::cout << "Sort by absolute value: " << arr << '\n';
    arr.sort();
    std::cout << "Default sort: " << arr << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 9, 12, -1, 3]
```

Output

```
Sort by absolute value: [1, -1, -2, 3, 5, 7, -9, 9, 10, 12]
Default sort: [-9, -2, -1, 1, 3, 5, 7, 9, 10, 12]
```

`array::stddev`

Return the standard deviation of the `array` elements.
```cpp
T stddev(size_t ddof = 0) const;
```

Parameters

* `ddof` Delta degrees of freedom. (See
[`numcpp::stddev`](4.%20Routines.md#basic-statistics) for full documentation.)

Returns

* The standard deviation of the `array` elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << arr.stddev() << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
5.95399
```

`array::sum`

Return the sum of the `array` elements.
```cpp
T sum() const;
```

Parameters

* None

Returns

* The sum of the `array` elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr;
    std::cin >> arr;
    std::cout << arr.sum() << '\n';
    return 0;
}
```

Input

```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

Output

```
55
```

`array::swap`

Exchanges the content of the `array` by the content of `other`. Implemented to
run in constant time.
```cpp
void swap(array &other);
```

Parameters

* `other` An `array` of the same type.

Returns

* None

Notes

* All valid iterators, references and views of both `*this` and `other` keep
their validity, and are now referring to the same elements they referred to
before the call, but in the other `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<int> arr1, arr2;
    std::cin >> arr1 >> arr2;
    std::cout << "Before swap:\n";
    std::cout << "arr1: " << arr1 << '\n';
    std::cout << "arr2: " << arr2 << '\n';
    arr1.swap(arr2);
    std::cout << "After swap:\n";
    std::cout << "arr1: " << arr1 << '\n';
    std::cout << "arr2: " << arr2 << '\n';
    return 0;
}
```

Input

```
[1, 5, 2, 0, 1]
[0, 7, -1, 2, 8, 3]
```

Output

```
Before swap:
arr1: [1, 5, 2, 0, 1]
arr2: [0, 7, -1, 2, 8, 3]
After swap:
arr1: [0, 7, -1, 2, 8, 3]
arr2: [1, 5, 2, 0, 1]
```

`array::var`

Return the variance of the `array` elements.
```cpp
T var(size_t ddof = 0) const;
```

Parameters

* `ddof` Delta degrees of freedom. (See
[`numcpp::var`](4.%20Routines.md#basic-statistics) for full documentation.)

Returns

* The variance of the `array` elements.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;
int main() {
    np::array<double> arr;
    std::cin >> arr;
    std::cout << "Biased: " << arr.var() << '\n';
    std::cout << "Unbiased: " << arr.var(1) << '\n';
    return 0;
}
```

Input

```
[1, -9, 5, 10, -2, 7, 8, 12, 0, 3]
```

Output

```
Biased: 35.45
Unbiased: 39.3889
```

`array::view`

Return a view of the `array` with the same data.
```cpp
array_view<T> view();
```

Parameters

* None

Returns

* An [`array_view`](1.1%20Array%20view.md) object, which has reference
semantics to the original `array`.

Example

```cpp
#include <iostream>
#include "numcpp/array.h"
#include "numcpp/io.h"
namespace np = numcpp;

void fill_view(np::array_view<int> view) {
    for (unsigned i = 0; i < view.size(); ++i) {
        view[i] = i;
    }
}

int main() {
    np::array<int> arr(10);
    fill_view(arr.view());
    std::cout << arr << '\n';
    return 0;
}
```

Output

```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```